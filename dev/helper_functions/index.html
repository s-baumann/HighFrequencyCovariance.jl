<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Helper Functions · HighFrequencyCovariance.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">HighFrequencyCovariance.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><span class="tocitem">First Steps with HighFrequencyCovariance.jl</span><ul><li><a class="tocitem" href="../1_algorithms/">Algorithms</a></li><li><a class="tocitem" href="../2_data_structures/">Data Structures</a></li><li><a class="tocitem" href="../3_WritingCode/">Writing Code</a></li><li><a class="tocitem" href="../9_references/">References</a></li></ul></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="../types/">Types</a></li><li><a class="tocitem" href="../functions/">Estimation Functions</a></li><li class="is-active"><a class="tocitem" href>Helper Functions</a><ul class="internal"><li><a class="tocitem" href="#Working-with-SortedDataFrame-structs"><span>Working with SortedDataFrame structs</span></a></li><li><a class="tocitem" href="#Working-with-CovarianceMatrix-structs"><span>Working with CovarianceMatrix structs</span></a></li><li><a class="tocitem" href="#Blocking-and-Regularisation-Functions"><span>Blocking and Regularisation Functions</span></a></li><li><a class="tocitem" href="#Monte-Carlo"><span>Monte Carlo</span></a></li><li><a class="tocitem" href="#For-getting-a-DataFrame-version-of-a-CovarianceMatrix-and-vice-versa."><span>For getting a DataFrame version of a CovarianceMatrix and vice versa.</span></a></li><li><a class="tocitem" href="#Internal-Functions-potentially-of-use-for-advanced-users"><span>Internal Functions potentially of use for advanced users</span></a></li></ul></li><li><a class="tocitem" href="../internals/">Internal Functions</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API</a></li><li class="is-active"><a href>Helper Functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Helper Functions</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/s-baumann/HighFrequencyCovariance.jl/blob/master/docs/src/helper_functions.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Helper-Functions"><a class="docs-heading-anchor" href="#Helper-Functions">Helper Functions</a><a id="Helper-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Helper-Functions" title="Permalink"></a></h1><ul><li><a href="#HighFrequencyCovariance.bnhls_2008"><code>HighFrequencyCovariance.bnhls_2008</code></a></li><li><a href="#HighFrequencyCovariance.fejer"><code>HighFrequencyCovariance.fejer</code></a></li><li><a href="#HighFrequencyCovariance.parzen"><code>HighFrequencyCovariance.parzen</code></a></li><li><a href="#HighFrequencyCovariance.quadratic_spectral"><code>HighFrequencyCovariance.quadratic_spectral</code></a></li><li><a href="#HighFrequencyCovariance.tukey_hanning"><code>HighFrequencyCovariance.tukey_hanning</code></a></li><li><a href="#HighFrequencyCovariance.HFC_Kernel"><code>HighFrequencyCovariance.HFC_Kernel</code></a></li><li><a href="#StochasticIntegrals.ItoSet"><code>StochasticIntegrals.ItoSet</code></a></li><li><a href="#HighFrequencyCovariance.blockwise_estimation"><code>HighFrequencyCovariance.blockwise_estimation</code></a></li><li><a href="#HighFrequencyCovariance.calculate_mean_abs_distance"><code>HighFrequencyCovariance.calculate_mean_abs_distance</code></a></li><li><a href="#HighFrequencyCovariance.combine_covariance_matrices"><code>HighFrequencyCovariance.combine_covariance_matrices</code></a></li><li><a href="#HighFrequencyCovariance.construct_matrix_from_eigen"><code>HighFrequencyCovariance.construct_matrix_from_eigen</code></a></li><li><a href="#HighFrequencyCovariance.cor2cov"><code>HighFrequencyCovariance.cor2cov</code></a></li><li><a href="#HighFrequencyCovariance.cov2cor"><code>HighFrequencyCovariance.cov2cor</code></a></li><li><a href="#HighFrequencyCovariance.cov2cor_and_vol"><code>HighFrequencyCovariance.cov2cor_and_vol</code></a></li><li><a href="#HighFrequencyCovariance.covariance"><code>HighFrequencyCovariance.covariance</code></a></li><li><a href="#HighFrequencyCovariance.dataframe_to_covariancematrix"><code>HighFrequencyCovariance.dataframe_to_covariancematrix</code></a></li><li><a href="#HighFrequencyCovariance.default_num_grids"><code>HighFrequencyCovariance.default_num_grids</code></a></li><li><a href="#HighFrequencyCovariance.duration"><code>HighFrequencyCovariance.duration</code></a></li><li><a href="#HighFrequencyCovariance.generate_random_path"><code>HighFrequencyCovariance.generate_random_path</code></a></li><li><a href="#HighFrequencyCovariance.get_all_refresh_times"><code>HighFrequencyCovariance.get_all_refresh_times</code></a></li><li><a href="#HighFrequencyCovariance.get_assets"><code>HighFrequencyCovariance.get_assets</code></a></li><li><a href="#HighFrequencyCovariance.get_correlation"><code>HighFrequencyCovariance.get_correlation</code></a></li><li><a href="#HighFrequencyCovariance.get_returns"><code>HighFrequencyCovariance.get_returns</code></a></li><li><a href="#HighFrequencyCovariance.get_volatility"><code>HighFrequencyCovariance.get_volatility</code></a></li><li><a href="#HighFrequencyCovariance.is_psd_matrix"><code>HighFrequencyCovariance.is_psd_matrix</code></a></li><li><a href="#HighFrequencyCovariance.iterate_higham"><code>HighFrequencyCovariance.iterate_higham</code></a></li><li><a href="#HighFrequencyCovariance.latest_value"><code>HighFrequencyCovariance.latest_value</code></a></li><li><a href="#HighFrequencyCovariance.make_nan_covariance_matrix"><code>HighFrequencyCovariance.make_nan_covariance_matrix</code></a></li><li><a href="#HighFrequencyCovariance.project_to_S"><code>HighFrequencyCovariance.project_to_S</code></a></li><li><a href="#HighFrequencyCovariance.project_to_U"><code>HighFrequencyCovariance.project_to_U</code></a></li><li><a href="#HighFrequencyCovariance.put_assets_into_blocks_by_trading_frequency"><code>HighFrequencyCovariance.put_assets_into_blocks_by_trading_frequency</code></a></li><li><a href="#HighFrequencyCovariance.random_value_in_interval"><code>HighFrequencyCovariance.random_value_in_interval</code></a></li><li><a href="#HighFrequencyCovariance.rearrange"><code>HighFrequencyCovariance.rearrange</code></a></li><li><a href="#HighFrequencyCovariance.squared_frobenius"><code>HighFrequencyCovariance.squared_frobenius</code></a></li><li><a href="#HighFrequencyCovariance.squared_frobenius_distance"><code>HighFrequencyCovariance.squared_frobenius_distance</code></a></li><li><a href="#HighFrequencyCovariance.subset_to_tick"><code>HighFrequencyCovariance.subset_to_tick</code></a></li><li><a href="#HighFrequencyCovariance.subset_to_time"><code>HighFrequencyCovariance.subset_to_time</code></a></li><li><a href="#HighFrequencyCovariance.ticks_per_asset"><code>HighFrequencyCovariance.ticks_per_asset</code></a></li><li><a href="#HighFrequencyCovariance.time_between_refreshes"><code>HighFrequencyCovariance.time_between_refreshes</code></a></li><li><a href="#HighFrequencyCovariance.valid_correlation_matrix"><code>HighFrequencyCovariance.valid_correlation_matrix</code></a></li><li><a href="#StochasticIntegrals.to_dataframe"><code>StochasticIntegrals.to_dataframe</code></a></li></ul><h2 id="Working-with-SortedDataFrame-structs"><a class="docs-heading-anchor" href="#Working-with-SortedDataFrame-structs">Working with SortedDataFrame structs</a><a id="Working-with-SortedDataFrame-structs-1"></a><a class="docs-heading-anchor-permalink" href="#Working-with-SortedDataFrame-structs" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="HighFrequencyCovariance.get_assets" href="#HighFrequencyCovariance.get_assets"><code>HighFrequencyCovariance.get_assets</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get_assets(ts::SortedDataFrame, obs_to_include::Integer = 10)</code></pre><p>This returns a vector of all of the assets in the <code>SortedDataFrame</code> with at least some number of observations (10 by default).</p><p><strong>Inputs</strong></p><ul><li><code>ts</code> - The tick data.</li><li><code>obs_to_include</code> - An integer for the minimum number of ticks in <code>ts</code> needed for the function to include that asset.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>Vector{Symbol}</code> with each asset.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/HighFrequencyCovariance.jl/blob/aaff35719be3a31ab073b7c8cc41daef3e3ec83c/src/00_Structs.jl#L50-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HighFrequencyCovariance.ticks_per_asset" href="#HighFrequencyCovariance.ticks_per_asset"><code>HighFrequencyCovariance.ticks_per_asset</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ticks_per_asset(ts::SortedDataFrame, assets::Vector{Symbol} = get_assets(ts))</code></pre><p>Count the number of observations for each asset.</p><p><strong>Inputs</strong></p><ul><li><code>ts</code> - The tick data</li><li><code>assets</code> - A vector with asset <code>Symbol</code>s.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>Dict</code> with the number of observations for each input asset.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/HighFrequencyCovariance.jl/blob/aaff35719be3a31ab073b7c8cc41daef3e3ec83c/src/00_Structs.jl#L311-L320">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HighFrequencyCovariance.duration" href="#HighFrequencyCovariance.duration"><code>HighFrequencyCovariance.duration</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">duration(ts::SortedDataFrame)</code></pre><p>The time elapsed between the first and the last tick in a <code>SortedDataFrame</code>.</p><p><strong>Inputs</strong></p><ul><li><code>ts</code> - Tick data.</li></ul><p><strong>Returns</strong></p><ul><li>A scalar representing this duration.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/HighFrequencyCovariance.jl/blob/aaff35719be3a31ab073b7c8cc41daef3e3ec83c/src/00_Structs.jl#L109-L117">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HighFrequencyCovariance.subset_to_tick" href="#HighFrequencyCovariance.subset_to_tick"><code>HighFrequencyCovariance.subset_to_tick</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">subset_to_tick(ts::SortedDataFrame, n::Integer)</code></pre><p>This subsets a <code>SortedDataFrame</code> to only the first n ticks.</p><p><strong>Inputs</strong></p><ul><li><code>ts</code> - Tick data.</li><li><code>n</code> - How many ticks to subset to.</li></ul><p><strong>Returns</strong></p><ul><li>A (smaller) <code>SortedDataFrame</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/HighFrequencyCovariance.jl/blob/aaff35719be3a31ab073b7c8cc41daef3e3ec83c/src/00_Structs.jl#L72-L81">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HighFrequencyCovariance.subset_to_time" href="#HighFrequencyCovariance.subset_to_time"><code>HighFrequencyCovariance.subset_to_time</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">subset_to_time(ts::SortedDataFrame, totime::Real)</code></pre><p>This subsets a <code>SortedDataFrame</code> to only the first observations up until some time.</p><p><strong>Inputs</strong></p><ul><li><code>ts</code> - Tick data.</li><li><code>totime</code> - Up to what time.</li></ul><p><strong>Returns</strong></p><ul><li>A (smaller) <code>SortedDataFrame</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/HighFrequencyCovariance.jl/blob/aaff35719be3a31ab073b7c8cc41daef3e3ec83c/src/00_Structs.jl#L93-L102">source</a></section></article><h2 id="Working-with-CovarianceMatrix-structs"><a class="docs-heading-anchor" href="#Working-with-CovarianceMatrix-structs">Working with CovarianceMatrix structs</a><a id="Working-with-CovarianceMatrix-structs-1"></a><a class="docs-heading-anchor-permalink" href="#Working-with-CovarianceMatrix-structs" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="HighFrequencyCovariance.covariance" href="#HighFrequencyCovariance.covariance"><code>HighFrequencyCovariance.covariance</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">covariance(cm::CovarianceMatrix, duration::Real)</code></pre><p>This makes a <code>Hermitian</code> matrix for the covariance matrix over some duration.</p><p><strong>Inputs</strong></p><ul><li><code>cm</code> - A <code>CovarianceMatrix</code> struct.</li><li><code>duration</code> - A duration. This should be in same units as used in estimating <code>cm</code>&#39;s volatilities.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>Hermitian</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/HighFrequencyCovariance.jl/blob/aaff35719be3a31ab073b7c8cc41daef3e3ec83c/src/01_helpers.jl#L50-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HighFrequencyCovariance.get_correlation" href="#HighFrequencyCovariance.get_correlation"><code>HighFrequencyCovariance.get_correlation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get_correlation(covar::CovarianceMatrix, asset1::Symbol, asset2::Symbol)</code></pre><p>Extract the correlation between two assets stored in a CovarianceMatrix.</p><p><strong>Inputs</strong></p><ul><li><code>covar</code> - A <code>CovarianceMatrix</code></li><li><code>asset1</code> - A <code>Symbol</code> representing an asset.</li><li><code>asset2</code> - A <code>Symbol</code> representing an asset.</li></ul><p><strong>Returns</strong></p><ul><li>A Scalar (the correlation coefficient).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/HighFrequencyCovariance.jl/blob/aaff35719be3a31ab073b7c8cc41daef3e3ec83c/src/00_Structs.jl#L240-L250">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HighFrequencyCovariance.get_volatility" href="#HighFrequencyCovariance.get_volatility"><code>HighFrequencyCovariance.get_volatility</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get_volatility(covar::CovarianceMatrix, asset1::Symbol)</code></pre><p>Get the volatility for a stock from a <code>CovarianceMatrix</code>.</p><p><strong>Inputs</strong></p><ul><li><code>covar</code> - A <code>CovarianceMatrix</code></li><li><code>asset1</code> - A <code>Symbol</code> representing an asset.</li></ul><p><strong>Returns</strong></p><ul><li>A Scalar (the volatility).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/HighFrequencyCovariance.jl/blob/aaff35719be3a31ab073b7c8cc41daef3e3ec83c/src/00_Structs.jl#L258-L267">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HighFrequencyCovariance.make_nan_covariance_matrix" href="#HighFrequencyCovariance.make_nan_covariance_matrix"><code>HighFrequencyCovariance.make_nan_covariance_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">make_nan_covariance_matrix(labels::Vector{Symbol})</code></pre><p>This makes an empty <code>CovarianceMatrix</code> struct with all volatilities and correlations being NaNs.</p><p><strong>Inputs</strong></p><ul><li><code>labels</code> - The names of the asset names for this (empty) <code>CovarianceMatrix</code>.</li></ul><p><strong>Returns</strong></p><ul><li>An (empty) <code>CovarianceMatrix</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/HighFrequencyCovariance.jl/blob/aaff35719be3a31ab073b7c8cc41daef3e3ec83c/src/00_Structs.jl#L168-L176">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HighFrequencyCovariance.combine_covariance_matrices" href="#HighFrequencyCovariance.combine_covariance_matrices"><code>HighFrequencyCovariance.combine_covariance_matrices</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">combine_covariance_matrices(vect::Vector{CovarianceMatrix{REAL}}, cor_weights::Vector{&lt;:Real} = repeat([1.0], length(vect)),
                            vol_weights::Vector{&lt;:Real} = cor_weights) where REAL&lt;:Real</code></pre><p>Combines a vector of <code>CovarianceMatrix</code> structs into one <code>CovarianceMatrix</code> struct.</p><p><strong>Inputs</strong></p><ul><li><code>vect</code> - A vector of <code>CovarianceMatrix</code> structs.</li><li><code>cor_weights</code> - A vector for how much to weight the correlations from each covariance matrix (by default they will be equalweighted).</li><li><code>vol_weights</code> - A vector for how much to weight the volatilities from each covariance matrix (by default they will be equalweighted).</li></ul><p><strong>Returns</strong></p><ul><li>A matrix and a vector of labels for each row/column of the matrix.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/HighFrequencyCovariance.jl/blob/aaff35719be3a31ab073b7c8cc41daef3e3ec83c/src/01_helpers.jl#L127-L138">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HighFrequencyCovariance.rearrange" href="#HighFrequencyCovariance.rearrange"><code>HighFrequencyCovariance.rearrange</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">rearrange(cm::CovarianceMatrix, labels::Vector{Symbol})</code></pre><p>Rearrange the order of labels in a <code>CovarianceMatrix</code>.</p><p><strong>Takes</strong></p><ul><li><code>cm</code> - A <code>CovarianceMatrix</code>.</li><li><code>labels</code> - A <code>Vector</code> of labels.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>CovarianceMatrix</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/HighFrequencyCovariance.jl/blob/aaff35719be3a31ab073b7c8cc41daef3e3ec83c/src/01_helpers.jl#L162-L171">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HighFrequencyCovariance.cov2cor" href="#HighFrequencyCovariance.cov2cor"><code>HighFrequencyCovariance.cov2cor</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">cov2cor(mat::AbstractMatrix)</code></pre><p>Converts a matrix (representing a covariance matrix) into a <code>Hermitian</code> correlation matrix and a vector of standard deviations.</p><p><strong>Inputs</strong></p><ul><li><code>cor</code> - A matrix.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>Hermitian</code>.</li><li>A <code>Vector</code> of standard deviations (not volatilities).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/HighFrequencyCovariance.jl/blob/aaff35719be3a31ab073b7c8cc41daef3e3ec83c/src/01_helpers.jl#L2-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HighFrequencyCovariance.cor2cov" href="#HighFrequencyCovariance.cor2cov"><code>HighFrequencyCovariance.cor2cov</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">cor2cov(cor::AbstractMatrix,sdevs::Vector{&lt;:Real})</code></pre><p>Converts a correlation matrix and some standard deviations into a <code>Hermitian</code> covariance matrix.</p><p><strong>Inputs</strong></p><ul><li><code>cor</code> - A correlation matrix.</li><li><code>sdevs</code> - A vector of standard deviations (not volatilities - use sdevs = sqrt(duration) .* volatilities to convert if necessary).</li></ul><p><strong>Returns</strong></p><ul><li>A <code>Hermitian</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/HighFrequencyCovariance.jl/blob/aaff35719be3a31ab073b7c8cc41daef3e3ec83c/src/01_helpers.jl#L35-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HighFrequencyCovariance.cov2cor_and_vol" href="#HighFrequencyCovariance.cov2cor_and_vol"><code>HighFrequencyCovariance.cov2cor_and_vol</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">cov2cor_and_vol(mat::AbstractMatrix, duration::Real)</code></pre><p>Converts a matrix (representing a covariance matrix) into a <code>Hermitian</code> correlation matrix and a vector of volatilities.</p><p><strong>Inputs</strong></p><ul><li><code>cor</code> - A correlation matrix.</li><li><code>duration</code> - The duration that the covariance matrix is for.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>Hermitian</code>.</li><li>A <code>Vector</code> of volatilities.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/HighFrequencyCovariance.jl/blob/aaff35719be3a31ab073b7c8cc41daef3e3ec83c/src/01_helpers.jl#L19-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HighFrequencyCovariance.construct_matrix_from_eigen" href="#HighFrequencyCovariance.construct_matrix_from_eigen"><code>HighFrequencyCovariance.construct_matrix_from_eigen</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">construct_matrix_from_eigen(eigenvalues::Vector{&lt;:Real}, eigenvectors::Matrix{&lt;:Real})</code></pre><p>Constructs a matrix from its eigenvalue decomposition.</p><p><strong>Inputs</strong></p><ul><li><code>eigenvalues</code> - A vector of eigenvalues.</li><li><code>eigenvectors</code> - A matrix of eigenvectors. The i&#39;th column corresponds to the i&#39;th eigenvalue.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>Matrix</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/HighFrequencyCovariance.jl/blob/aaff35719be3a31ab073b7c8cc41daef3e3ec83c/src/01_helpers.jl#L65-L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HighFrequencyCovariance.get_returns" href="#HighFrequencyCovariance.get_returns"><code>HighFrequencyCovariance.get_returns</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get_returns(dd::DataFrame; rescale_for_duration::Bool = false)</code></pre><p>Converts a long format <code>DataFrame</code> of prices into a <code>DataFrame</code> of returns.</p><p><strong>Inputs</strong></p><ul><li><code>dd</code> - A <code>DataFrame</code> with a column called :Time and all other columns being asset prices in each period.</li><li><code>rescale_for_duration</code> - Should returns be rescaled to reflect a common time interval.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>DataFrame</code> of returns.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/HighFrequencyCovariance.jl/blob/aaff35719be3a31ab073b7c8cc41daef3e3ec83c/src/01_helpers.jl#L94-L103">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HighFrequencyCovariance.valid_correlation_matrix" href="#HighFrequencyCovariance.valid_correlation_matrix"><code>HighFrequencyCovariance.valid_correlation_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">valid_correlation_matrix(mat::Hermitian)
valid_correlation_matrix(covar::CovarianceMatrix)</code></pre><p>Test if a <code>Hermitian</code> matrix is a valid correlation matrix. This is done by testing if it is psd, if it has a unit diagonal and if all other elements are less than one. If a <code>Hermitian</code> is input then it will be tested. If a <code>CovarianceMatrix</code> is input then its correlation matrix will be tested.</p><p><strong>Inputs</strong></p><ul><li>A <code>Hermitian</code> matrix or a <code>CovarianceMatrix</code></li></ul><p><strong>Returns</strong></p><ul><li>A <code>Bool</code> that is true if mat is a valid correlation matrix and false if not.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/HighFrequencyCovariance.jl/blob/aaff35719be3a31ab073b7c8cc41daef3e3ec83c/src/00_Structs.jl#L292-L302">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HighFrequencyCovariance.is_psd_matrix" href="#HighFrequencyCovariance.is_psd_matrix"><code>HighFrequencyCovariance.is_psd_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">is_psd_matrix(mat::Hermitian)
is_psd_matrix(covar::CovarianceMatrix)</code></pre><p>Test if a matrix is psd (Positive Semi-Definite). This is done by seeing if all eigenvalues are positive. If a <code>Hermitian</code> is input then it will be tested. If a <code>CovarianceMatrix</code> is input then its correlation matrix will be tested.</p><p><strong>Inputs</strong></p><ul><li>A <code>Hermitian</code> matrix or a <code>CovarianceMatrix</code></li></ul><p><strong>Returns</strong></p><ul><li>A <code>Bool</code> that is true if mat is psd and false if not.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/HighFrequencyCovariance.jl/blob/aaff35719be3a31ab073b7c8cc41daef3e3ec83c/src/00_Structs.jl#L274-L284">source</a></section></article><h2 id="Blocking-and-Regularisation-Functions"><a class="docs-heading-anchor" href="#Blocking-and-Regularisation-Functions">Blocking and Regularisation Functions</a><a id="Blocking-and-Regularisation-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Blocking-and-Regularisation-Functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="HighFrequencyCovariance.put_assets_into_blocks_by_trading_frequency" href="#HighFrequencyCovariance.put_assets_into_blocks_by_trading_frequency"><code>HighFrequencyCovariance.put_assets_into_blocks_by_trading_frequency</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">put_assets_into_blocks_by_trading_frequency(ts::SortedDataFrame, obs_multiple_for_new_block::Real, func::Symbol, optional_parameters::NamedTuple = NamedTuple())</code></pre><p>This makes a DataFrame that describes how to estimate the covariance matrix blockwise.</p><p><strong>Inputs</strong></p><ul><li><code>ts</code> - The tick data.</li><li><code>obs_multiple_for_new_block</code> - The relative number of ticks needed before a new block is made. So if this is 1.2 that means a new group is made when one asset has 20% or more ticks than the slowest traded asset in the previous block.</li><li><code>func</code> - A symbol representing the covariance estimation function to be used.</li><li><code>optional_parameters</code> - Optional parameters to be used in the <code>func</code> function.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>DataFrame</code> representing what estimations should be performed. The order of rows in the <code>DataFrame</code> shows the order of estimation.</li></ul><p><strong>References</strong></p><p>Hautsch, N., Kyj, L.M. and Oomen, R.C.A. (2012), A blocking and regularization approach to high‐dimensional realized covariance estimation. J. Appl. Econ., 27: 625-645</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/HighFrequencyCovariance.jl/blob/aaff35719be3a31ab073b7c8cc41daef3e3ec83c/src/40_Blocking.jl#L46-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HighFrequencyCovariance.blockwise_estimation" href="#HighFrequencyCovariance.blockwise_estimation"><code>HighFrequencyCovariance.blockwise_estimation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">blockwise_estimation(ts::SortedDataFrame, blocking_frame::DataFrame)</code></pre><p>Run a series of covariance estimations and combine the results. Two things should be input, a SortedDataFrame with the price update data and a dataframe describing what estimations should be performed. This should be of the same form as is output by <code>put_assets_into_blocks_by_trading_frequency</code> (although the actual estimations can be customised to something different as to what that function outputs).</p><p><strong>Inputs</strong></p><ul><li><code>ts</code> - The tick data.</li><li><code>blocking_frame</code> - A <code>DataFrame</code> representing what estimations to do and in what order. This is often be one generated by the <code>put_assets_into_blocks_by_trading_frequency</code> function (and potentially then modified).</li></ul><p><strong>Returns</strong></p><ul><li>A <code>CovarianceMatrix</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/HighFrequencyCovariance.jl/blob/aaff35719be3a31ab073b7c8cc41daef3e3ec83c/src/40_Blocking.jl#L75-L86">source</a></section></article><h2 id="Monte-Carlo"><a class="docs-heading-anchor" href="#Monte-Carlo">Monte Carlo</a><a id="Monte-Carlo-1"></a><a class="docs-heading-anchor-permalink" href="#Monte-Carlo" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="HighFrequencyCovariance.generate_random_path" href="#HighFrequencyCovariance.generate_random_path"><code>HighFrequencyCovariance.generate_random_path</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">generate_random_path(dimensions::Integer, ticks::Integer; syncronous::Bool = false, twister::MersenneTwister = MersenneTwister(1), minvol::Real = 0.0, maxvol::Real = 0.02,
                     min_refresh_rate::Real = 1.0, max_refresh_rate::Real = 5.0, min_noise_var::Real = 0.0, max_noise_var::Real = 0.01, assets::Union{Vector,Missing} = missing,
                     brownian_corr_matrix::Union{Hermitian,Missing} = missing, vols::Union{Vector,Missing} = missing)</code></pre><p>Generate a random path of price updates with a specified number of dimensions and ticks. There are options for whether the data is syncronous or asyncronous, the volatility of the price processes, the refresh rate on the (exponential) arrival times of price updates, the minimum and the maximum microstructure noises.</p><p><strong>Inputs</strong></p><ul><li><code>dimensions</code> - The number of assets.</li><li><code>ticks</code> - The number of ticks to produce.</li><li><code>syncronous</code> - Should ticks be syncronous (for each asset) or asyncronous.</li><li><code>twister</code> - The MersenneTwister used for RNG.</li><li><code>minvol</code> - The minimum volatility in sampling (only used if vols is missing).</li><li><code>maxvol</code> - The maximum volatility in sampling (only used if vols is missing).</li><li><code>min_refresh_rate</code> - The minimum refresh rate in sampling.</li><li><code>max_refresh_rate</code> - The maximum refresh rate in sampling.</li><li><code>min_noise_var</code>  - The minimum assetwise microstructure noise variance.</li><li><code>max_noise_var</code>  - The minimum assetwise microstructure noise variance.</li><li><code>assets</code> - The names of the assets that you want to use. The length of this must be equal to the <code>dimensions</code> input.</li><li><code>brownian_corr_matrix</code> - The correlation matrix to use. This is sampled from the Inverse Wishart distribution if none is input.</li><li><code>vols</code> - The correlation matrix to use. This is sampled from the Inverse Wishart distribution if none is input.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>SortedDataFrame</code> of tick data.</li><li>A <code>CovarianceMatrix</code> representing the true data generation process used in making the tick data.</li><li>A <code>Dict</code> of microstructure noise variances for each asset.</li><li>A <code>Dict</code> of update rates for each asset.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/HighFrequencyCovariance.jl/blob/aaff35719be3a31ab073b7c8cc41daef3e3ec83c/src/03_MonteCarlo.jl#L3-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticIntegrals.ItoSet" href="#StochasticIntegrals.ItoSet"><code>StochasticIntegrals.ItoSet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ItoSet(covariance_matrix::CovarianceMatrix{&lt;:Real})</code></pre><p>Convert a <code>CovarianceMatrix</code> into an <code>ItoSet</code> from the StochasticIntegrals package. This package can then be used to do things like generate draws from the Multivariate Gaussian corresponding to the covariance matrix and other things.</p><p><strong>Inputs</strong></p><ul><li><code>covariance_matrix</code> - The <code>CovarianceMatrix</code> that you want to convert into an <code>StochasticIntegrals.ItoSet</code></li></ul><p><strong>Returns</strong></p><ul><li>A <code>StochasticIntegrals.ItoSet</code> struct.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/HighFrequencyCovariance.jl/blob/aaff35719be3a31ab073b7c8cc41daef3e3ec83c/src/03_MonteCarlo.jl#L61-L71">source</a></section></article><h2 id="For-getting-a-DataFrame-version-of-a-CovarianceMatrix-and-vice-versa."><a class="docs-heading-anchor" href="#For-getting-a-DataFrame-version-of-a-CovarianceMatrix-and-vice-versa.">For getting a DataFrame version of a CovarianceMatrix and vice versa.</a><a id="For-getting-a-DataFrame-version-of-a-CovarianceMatrix-and-vice-versa.-1"></a><a class="docs-heading-anchor-permalink" href="#For-getting-a-DataFrame-version-of-a-CovarianceMatrix-and-vice-versa." title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="StochasticIntegrals.to_dataframe" href="#StochasticIntegrals.to_dataframe"><code>StochasticIntegrals.to_dataframe</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">to_dataframe(covar::CovarianceMatrix, othercols::Dict = Dict{Symbol,Any}(); delete_duplicate_correlations::Bool = true)</code></pre><p>Convert a CovarianceMatrix to a <code>DataFrame</code> format.</p><p><strong>Inputs</strong></p><ul><li><code>covar</code> - The <code>CovarianceMatrix</code></li><li><code>othercols</code> - This adds columns to the <code>DataFrame</code>. For instance if it is Dict{Symbol,String}([:pc] .=&gt; [&quot;Fred&#39;s PC&quot;]), then there will be a column indicating that this estimation was done on Fred&#39;s PC.</li><li><code>delete_duplicate_correlations</code> - Should the unnecessary correlations be included (as correlation matrices are symmetric half the entries duplicate information).</li></ul><p><strong>Returns</strong></p><ul><li>A <code>DataFrame</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/HighFrequencyCovariance.jl/blob/aaff35719be3a31ab073b7c8cc41daef3e3ec83c/src/04_Serialisation.jl#L3-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HighFrequencyCovariance.dataframe_to_covariancematrix" href="#HighFrequencyCovariance.dataframe_to_covariancematrix"><code>HighFrequencyCovariance.dataframe_to_covariancematrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">dataframe_to_covariancematrix(dd::DataFrame)</code></pre><p>Convert a <code>CovarianceMatrix</code> to a <code>DataFrame</code> format.</p><p><strong>Inputs</strong></p><ul><li><code>dd</code> - A <code>DataFrame</code> of the form generated by the <code>to_dataframe</code> function.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>CovarianceMatrix</code> struct.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/HighFrequencyCovariance.jl/blob/aaff35719be3a31ab073b7c8cc41daef3e3ec83c/src/04_Serialisation.jl#L30-L38">source</a></section></article><h2 id="Internal-Functions-potentially-of-use-for-advanced-users"><a class="docs-heading-anchor" href="#Internal-Functions-potentially-of-use-for-advanced-users">Internal Functions potentially of use for advanced users</a><a id="Internal-Functions-potentially-of-use-for-advanced-users-1"></a><a class="docs-heading-anchor-permalink" href="#Internal-Functions-potentially-of-use-for-advanced-users" title="Permalink"></a></h2><h3 id="Metrics-for-distances-between-CovarianceMatrix-structs"><a class="docs-heading-anchor" href="#Metrics-for-distances-between-CovarianceMatrix-structs">Metrics for distances between CovarianceMatrix structs</a><a id="Metrics-for-distances-between-CovarianceMatrix-structs-1"></a><a class="docs-heading-anchor-permalink" href="#Metrics-for-distances-between-CovarianceMatrix-structs" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="HighFrequencyCovariance.calculate_mean_abs_distance" href="#HighFrequencyCovariance.calculate_mean_abs_distance"><code>HighFrequencyCovariance.calculate_mean_abs_distance</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">calculate_mean_abs_distance(cov1::CovarianceMatrix, cov2::CovarianceMatrix)</code></pre><p>Calculates the mean absolute distance (elementwise in L1 norm) between two <code>CovarianceMatrix</code>s. Undefined if any labels differ between the two <code>CovarianceMatrix</code>s.</p><p><strong>Inputs</strong></p><ul><li><code>cov1</code> - The first <code>CovarianceMatrix</code></li><li><code>cov2</code> - The second <code>CovarianceMatrix</code></li></ul><p><strong>Returns</strong></p><ul><li>An <code>Tuple</code> with the distance for correlations in first entry and distance for volatilities in the second.</li></ul><pre><code class="language-none">calculate_mean_abs_distance(d1::Dict{Symbol,&lt;:Real}, d2::Dict{Symbol,&lt;:Real})</code></pre><p>Calculates the mean absolute distance (elementwise in L1 norm) between two <code>CovarianceMatrix</code>s.</p><p><strong>Inputs</strong></p><ul><li><code>d1</code> - The first <code>Dict</code></li><li><code>d2</code> - The second <code>Dict</code></li></ul><p><strong>Returns</strong></p><ul><li>A scalar with the mean distance between matching elements.</li></ul><pre><code class="language-none">calculate_mean_abs_distance(d1::Tuple{Dict{Symbol,&lt;:Real},Dict{Symbol,&lt;:Real}}, d2::Tuple{Dict{Symbol,&lt;:Real},Dict{Symbol,&lt;:Real}})</code></pre><p>Calculates the distance between the first element of d1 and first of d2. And second elements of each. Returns a <code>Tuple</code> with two scalars for the distances between each element and the corresponding element of the other.</p><p><strong>Inputs</strong></p><ul><li><code>d1</code> - The first <code>Tuple</code></li><li><code>d2</code> - The second <code>Tuple</code></li></ul><p><strong>Returns</strong></p><ul><li>A <code>Tuple</code> with two scalars representing the distances between <code>Tuple</code> elements.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/HighFrequencyCovariance.jl/blob/aaff35719be3a31ab073b7c8cc41daef3e3ec83c/src/00_Structs.jl#L187-L217">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HighFrequencyCovariance.squared_frobenius" href="#HighFrequencyCovariance.squared_frobenius"><code>HighFrequencyCovariance.squared_frobenius</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">squared_frobenius(x1::AbstractMatrix)</code></pre><p>Rearrange the squared frobenius norm of a matrix. Returns a real.</p><p><strong>Inputs</strong></p><ul><li><code>x1</code> The matrix that you want the squared frobenius norm for.</li></ul><p><strong>Returns</strong></p><ul><li>A Scalar.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/HighFrequencyCovariance.jl/blob/aaff35719be3a31ab073b7c8cc41daef3e3ec83c/src/01_helpers.jl#L193-L201">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HighFrequencyCovariance.squared_frobenius_distance" href="#HighFrequencyCovariance.squared_frobenius_distance"><code>HighFrequencyCovariance.squared_frobenius_distance</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">squared_frobenius_distance(x1::AbstractMatrix, x2::AbstractMatrix = x1)</code></pre><p>Rearrange the squared frobenius distance between two matrices. Returns a real.</p><p><strong>Inputs</strong></p><ul><li><code>x1</code> The first matrix.</li><li><code>x2</code> The second matrix.</li></ul><p><strong>Returns</strong></p><ul><li>A Scalar.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/HighFrequencyCovariance.jl/blob/aaff35719be3a31ab073b7c8cc41daef3e3ec83c/src/01_helpers.jl#L180-L189">source</a></section></article><h3 id="Used-in-volatility-estimation-techniques"><a class="docs-heading-anchor" href="#Used-in-volatility-estimation-techniques">Used in volatility estimation techniques</a><a id="Used-in-volatility-estimation-techniques-1"></a><a class="docs-heading-anchor-permalink" href="#Used-in-volatility-estimation-techniques" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="HighFrequencyCovariance.default_num_grids" href="#HighFrequencyCovariance.default_num_grids"><code>HighFrequencyCovariance.default_num_grids</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">default_num_grids(ts::SortedDataFrame)</code></pre><p>This gives a default number of intervals to divide a series of ticks over for the purposes of estimating returns and volatility.</p><p><strong>Inputs</strong></p><ul><li><code>ts</code> - The tick data.</li></ul><p><strong>Returns</strong></p><ul><li>An integer for the number of intervals.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/HighFrequencyCovariance.jl/blob/aaff35719be3a31ab073b7c8cc41daef3e3ec83c/src/11_volatility_two_scales.jl#L9-L17">source</a></section></article><h3 id="Used-in-covariance-estimation-techniques"><a class="docs-heading-anchor" href="#Used-in-covariance-estimation-techniques">Used in covariance estimation techniques</a><a id="Used-in-covariance-estimation-techniques-1"></a><a class="docs-heading-anchor-permalink" href="#Used-in-covariance-estimation-techniques" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="HighFrequencyCovariance.get_all_refresh_times" href="#HighFrequencyCovariance.get_all_refresh_times"><code>HighFrequencyCovariance.get_all_refresh_times</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get_all_refresh_times(ts::SortedDataFrame, assets::Vector{Symbol} = get_assets(ts); start_time::R = minimum(ts.df[:,ts.time])) where R&lt;:Real</code></pre><p>Get a vector of all refresh times when all assets have an updated price. So if there are assets A and B that trade at times (1,5,6,7,10) and (2,5,7,9) then the refresh times are (2,5,7,10) as at these four times there are updated prices for all assets that have happened since the previous refresh time.</p><p><strong>Inputs</strong></p><ul><li><code>ts</code> - The tick data.</li><li><code>assets</code> - The assets of interest.</li><li><code>start_time</code> - From what time should we start looking for updated prices.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>Vector</code> of refresh times.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/HighFrequencyCovariance.jl/blob/aaff35719be3a31ab073b7c8cc41daef3e3ec83c/src/02_subsample_ticks.jl#L80-L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HighFrequencyCovariance.latest_value" href="#HighFrequencyCovariance.latest_value"><code>HighFrequencyCovariance.latest_value</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">latest_value(ts::SortedDataFrame, at_times::Vector{R}; assets::Vector{Symbol} = get_assets(ts)) where R&lt;:Real</code></pre><p>Get the latest price at a each input time.</p><p><strong>Inputs</strong></p><ul><li><code>ts</code> - The tick data.</li><li><code>at_times</code> - The times you want the latest prices for.</li><li><code>assets</code> - The assets you want latest prices for.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>DataFrame</code>. Rows are for each time specified in at_times. Columns are for each asset.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/HighFrequencyCovariance.jl/blob/aaff35719be3a31ab073b7c8cc41daef3e3ec83c/src/02_subsample_ticks.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HighFrequencyCovariance.time_between_refreshes" href="#HighFrequencyCovariance.time_between_refreshes"><code>HighFrequencyCovariance.time_between_refreshes</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">time_between_refreshes(ts::SortedDataFrame; assets::Vector{Symbol} = get_assets(ts))</code></pre><p>Get a <code>DataFrame</code> showing how many time is between each refresh and how many ticks in total.</p><p><strong>Inputs</strong></p><ul><li><code>ts</code> - Tick data.</li><li><code>assets</code> - A <code>Vector</code> of labels.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>DataFrame</code> summarising the average number of time between ticks for each asset.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/HighFrequencyCovariance.jl/blob/aaff35719be3a31ab073b7c8cc41daef3e3ec83c/src/01_helpers.jl#L209-L218">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HighFrequencyCovariance.random_value_in_interval" href="#HighFrequencyCovariance.random_value_in_interval"><code>HighFrequencyCovariance.random_value_in_interval</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">random_value_in_interval(ts::SortedDataFrame, at_times::Vector{R}; assets::Vector{Symbol} = get_assets(ts), twister_arb_value_in_interval::MersenneTwister = MersenneTwister(2604)) where R&lt;:Real</code></pre><p>Get a random value in an interval. So if you input times 1,7,8 then for the second entry it will pick a random update (if any exist) between times 1 and 7.</p><p><strong>Inputs</strong></p><ul><li><code>ts</code> - The tick data.</li><li><code>at_times</code> - The times that seperate the intervals of interest.</li><li><code>assets</code> - The assets of interest.</li><li><code>twister_arb_value_in_interval</code> - The RNG used in selecting the random interval.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>DataFrame</code> with prices for each asset from random ticks in each interval.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/HighFrequencyCovariance.jl/blob/aaff35719be3a31ab073b7c8cc41daef3e3ec83c/src/02_subsample_ticks.jl#L46-L57">source</a></section></article><h3 id="Kernels-used-in-the-BNHLS-method"><a class="docs-heading-anchor" href="#Kernels-used-in-the-BNHLS-method">Kernels used in the BNHLS method</a><a id="Kernels-used-in-the-BNHLS-method-1"></a><a class="docs-heading-anchor-permalink" href="#Kernels-used-in-the-BNHLS-method" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="HighFrequencyCovariance.HFC_Kernel" href="#HighFrequencyCovariance.HFC_Kernel"><code>HighFrequencyCovariance.HFC_Kernel</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A kernel used in the bnhls covariance method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/HighFrequencyCovariance.jl/blob/aaff35719be3a31ab073b7c8cc41daef3e3ec83c/src/21_covariance_bnhls.jl#L1-L3">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HighFrequencyCovariance.parzen" href="#HighFrequencyCovariance.parzen"><code>HighFrequencyCovariance.parzen</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>A parzen kernel used in the bnhls covariance method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/HighFrequencyCovariance.jl/blob/aaff35719be3a31ab073b7c8cc41daef3e3ec83c/src/21_covariance_bnhls.jl#L20-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HighFrequencyCovariance.quadratic_spectral" href="#HighFrequencyCovariance.quadratic_spectral"><code>HighFrequencyCovariance.quadratic_spectral</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>A quadratic_spectral kernel used in the bnhls covariance method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/HighFrequencyCovariance.jl/blob/aaff35719be3a31ab073b7c8cc41daef3e3ec83c/src/21_covariance_bnhls.jl#L25-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HighFrequencyCovariance.fejer" href="#HighFrequencyCovariance.fejer"><code>HighFrequencyCovariance.fejer</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>A fejer kernel used in the bnhls covariance method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/HighFrequencyCovariance.jl/blob/aaff35719be3a31ab073b7c8cc41daef3e3ec83c/src/21_covariance_bnhls.jl#L30-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HighFrequencyCovariance.tukey_hanning" href="#HighFrequencyCovariance.tukey_hanning"><code>HighFrequencyCovariance.tukey_hanning</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>A tukey_hanning kernel used in the bnhls covariance method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/HighFrequencyCovariance.jl/blob/aaff35719be3a31ab073b7c8cc41daef3e3ec83c/src/21_covariance_bnhls.jl#L35-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HighFrequencyCovariance.bnhls_2008" href="#HighFrequencyCovariance.bnhls_2008"><code>HighFrequencyCovariance.bnhls_2008</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>A bnhls_2008 kernel used in the bnhls covariance method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/HighFrequencyCovariance.jl/blob/aaff35719be3a31ab073b7c8cc41daef3e3ec83c/src/21_covariance_bnhls.jl#L40-L42">source</a></section></article><h3 id="Used-in-nearest-correlation-regularisation"><a class="docs-heading-anchor" href="#Used-in-nearest-correlation-regularisation">Used in nearest correlation regularisation</a><a id="Used-in-nearest-correlation-regularisation-1"></a><a class="docs-heading-anchor-permalink" href="#Used-in-nearest-correlation-regularisation" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="HighFrequencyCovariance.project_to_S" href="#HighFrequencyCovariance.project_to_S"><code>HighFrequencyCovariance.project_to_S</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">project_to_S(A::Hermitian, W_root::Union{Hermitian,Diagonal}; W_inv_sqrt::Union{Hermitian,Diagonal} = sqrt_psd(inv(W_root^2)))
project_to_S(A::Diagonal, W_root::Union{Hermitian,Diagonal}; W_inv_sqrt::Union{Hermitian,Diagonal,Missing} = missing)</code></pre><p>This maps a matrix to the nearest psd matrix. W<em>root should be the principal square root of a psd Hermitian weighting matrix, W. `W</em>inv<em>sqrt<code>should be the corresponding square root of the inverse of W.</code>nearest</em>psd_matrix` is a simpler interface for this function however it does not allow weighting matrices to be specified.</p><p><strong>Inputs</strong></p><ul><li><code>A</code> - The matrix you want to project to the S space. This can be a <code>Diagonal</code> or a <code>Hermitian</code>. Note that if you input a <code>Diagonal</code> matrix then it is already in the S space and so it will be returned without any calculation.</li><li><code>W_root</code> - The inverse weighting matrix.</li><li><code>W_inv_sqrt</code> - The root of <code>W_root</code>. This is calculated if you don&#39;t have it but it can save some calculation effort if you already have it.</li></ul><p><strong>Outputs</strong></p><ul><li>A <code>Hermitian</code>.</li></ul><p><strong>References</strong></p><p>Higham, N. J. 2001. Theorem 3.2</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/HighFrequencyCovariance.jl/blob/aaff35719be3a31ab073b7c8cc41daef3e3ec83c/src/31_Regularisation_NearestCorrelationMatrix.jl#L44-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HighFrequencyCovariance.project_to_U" href="#HighFrequencyCovariance.project_to_U"><code>HighFrequencyCovariance.project_to_U</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">project_to_U(A::Union{Diagonal,Hermitian}, invW::Hermitian)</code></pre><p>This maps the Hermitian/Hermitian matrix <code>A</code> to the nearest matrix in the U space (the space of all unit diagonal matrices as defined by Higham 2001). The inverse weight matrix <code>invW</code> determines how much to adjust each element to get it to be unit diagonal. In other words it is used to determine what is the nearest correlation matrix. The weight matrix must be Hermitian positive definite. We use the W-norm (as defined by Higham 2001).</p><p><strong>Inputs</strong></p><ul><li><code>A</code> - The matrix you want to project to the U space</li><li><code>invW</code> - The inverse weighting matrix.</li></ul><p><strong>Outputs</strong></p><ul><li>A <code>Diagonal</code> or a <code>Hermitian</code>.</li></ul><p><strong>References</strong></p><p>Higham, N. J. 2001. Bottom of page 335.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/HighFrequencyCovariance.jl/blob/aaff35719be3a31ab073b7c8cc41daef3e3ec83c/src/31_Regularisation_NearestCorrelationMatrix.jl#L16-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HighFrequencyCovariance.iterate_higham" href="#HighFrequencyCovariance.iterate_higham"><code>HighFrequencyCovariance.iterate_higham</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">iterate_higham(Y::Union{Hermitian,Diagonal}, Dykstra::Union{Hermitian,Diagonal}, W_root::Union{Hermitian,Diagonal}, W_inv::Union{Hermitian,Diagonal}, W_inv_sqrt::Union{Hermitian,Diagonal})</code></pre><p>Do one iterate mapping the input matrix to the S space (of psd matrices) and then to the U space (unit diagonal and all other entries below 1 in absolute value). Returns the updated matrix and the next iterate&#39;s Dykstra correction.</p><p><strong>Inputs</strong></p><ul><li><code>Y</code> - The matrix you want to project to the iterate towards the space of valid correlation matrices.</li><li><code>Dykstra</code> - The Dykstra correction matrix.</li><li><code>W_root</code> - The root of <code>W</code>.</li><li><code>W_inv</code> - The inverse of <code>W</code>.</li><li><code>W_inv_sqrt</code> - The root of the inverse of <code>W</code>.</li></ul><p><strong>Outputs</strong></p><ul><li>A <code>Hermitian</code>.</li><li>An updated Dykstra correction matrix.</li></ul><p><strong>References</strong></p><p>Higham, N. J. 2001. Algorithm 3.3</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/HighFrequencyCovariance.jl/blob/aaff35719be3a31ab073b7c8cc41daef3e3ec83c/src/31_Regularisation_NearestCorrelationMatrix.jl#L72-L89">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../functions/">« Estimation Functions</a><a class="docs-footer-nextpage" href="../internals/">Internal Functions »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Friday 6 August 2021 22:36">Friday 6 August 2021</span>. Using Julia version 1.6.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

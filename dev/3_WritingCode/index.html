<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Writing Code · HighFrequencyCovariance.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">HighFrequencyCovariance.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><span class="tocitem">First Steps with HighFrequencyCovariance.jl</span><ul><li><a class="tocitem" href="../1_algorithms/">Algorithms</a></li><li><a class="tocitem" href="../2_data_structures/">Data Structures</a></li><li class="is-active"><a class="tocitem" href>Writing Code</a><ul class="internal"><li><a class="tocitem" href="#Loading-in-data"><span>Loading in data</span></a></li><li><a class="tocitem" href="#Estimating-Volatility"><span>Estimating Volatility</span></a></li><li><a class="tocitem" href="#Estimating-a-covariance-matrix"><span>Estimating a covariance matrix</span></a></li></ul></li><li><a class="tocitem" href="../9_references/">References</a></li></ul></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="../types/">Types</a></li><li><a class="tocitem" href="../functions/">Estimation Functions</a></li><li><a class="tocitem" href="../helper_functions/">Helper Functions</a></li><li><a class="tocitem" href="../internals/">Internal Functions</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">First Steps with HighFrequencyCovariance.jl</a></li><li class="is-active"><a href>Writing Code</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Writing Code</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/s-baumann/HighFrequencyCovariance.jl/blob/master/docs/src/3_WritingCode.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Using-HighFrequencyCovariance"><a class="docs-heading-anchor" href="#Using-HighFrequencyCovariance">Using HighFrequencyCovariance</a><a id="Using-HighFrequencyCovariance-1"></a><a class="docs-heading-anchor-permalink" href="#Using-HighFrequencyCovariance" title="Permalink"></a></h1><h2 id="Loading-in-data"><a class="docs-heading-anchor" href="#Loading-in-data">Loading in data</a><a id="Loading-in-data-1"></a><a class="docs-heading-anchor-permalink" href="#Loading-in-data" title="Permalink"></a></h2><p>We first load our data into a <code>DataFrame</code>. As an example we have a <code>DataFrame</code> of price updates (like that in <code>df</code> in the below code block). Then we can put our data into a <code>SortedDataFrame</code> by putting the <code>DataFrame</code> and the names of the time, label and value columns into the constructor:</p><pre><code class="nohighlight hljs">using HighFrequencyCovariance
using DataFrames
# Making example data
df = DataFrame(:stock =&gt; [:A,:B,:A,:A,:A,:B,:A,:B,:B], :time =&gt; [1,2,3,4,5,5,6,7,8],
               :logprice =&gt; [1.01,2.0,1.011,1.02,1.011,2.2,1.0001,2.2,2.3])
# Making a SortedDataFrame
ts = SortedDataFrame(df, :time, :stock, :logprice)</code></pre><p>In a real setting this is how we would turn our <code>DataFrame</code> of data into a <code>SortedDataFrame</code>.</p><p>For the succeeding sections it is useful to get more realistic time series data. So we will generate some Monte Carlo data here using the <code>generate_random_path</code> function which generates a random correlation matrix, volatilities, price update times and microstructure noises and generates a <code>SortedDataFrame</code> from a random time series consistent with these.</p><pre><code class="nohighlight hljs">using HighFrequencyCovariance
using Random
dims = 4
ticks = 10000
ts, true_covar, true_micro_noise, true_update_rates = generate_random_path(dims, ticks, twister = MersenneTwister(2))</code></pre><h2 id="Estimating-Volatility"><a class="docs-heading-anchor" href="#Estimating-Volatility">Estimating Volatility</a><a id="Estimating-Volatility-1"></a><a class="docs-heading-anchor-permalink" href="#Estimating-Volatility" title="Permalink"></a></h2><p>We can use the <code>SortedDataFrame</code> we have generated (in the <code>ts</code> variable) to estimate the volatility of each asset:</p><pre><code class="nohighlight hljs">assets         = get_assets(ts)
simple_vol     = estimate_volatility(ts, assets, :simple_volatility)
two_scales_vol = estimate_volatility(ts, assets, :two_scales_volatility)</code></pre><p>Now the true volatility is contained in <code>true_covar.volatility</code>. We can present these true volatilities alongside the two estimated volatilities</p><pre><code class="nohighlight hljs">using DataFrames
true_volatility = Dict{Symbol,Float64}(true_covar.labels .=&gt; true_covar.volatility)
summary_frame = vcat(DataFrame.([true_volatility, simple_vol, two_scales_vol] )... )
summary_frame = hcat(DataFrame(Dict(:estimation =&gt; [&quot;True&quot;, &quot;Simple&quot;, &quot;2 Scales&quot;])), summary_frame)
print(summary_frame)
# │ Row │ estimation │ asset_1   │ asset_2   │ asset_3    │ asset_4   │
# │     │ String     │ Float64   │ Float64   │ Float64    │ Float64   │
# ├─────┼────────────┼───────────┼───────────┼────────────┼───────────┤
# │ 1   │ True       │ 0.0157077 │ 0.0137856 │ 0.00484516 │ 0.0142265 │
# │ 2   │ Simple     │ 0.0178855 │ 0.0284619 │ 0.00502814 │ 0.0129842 │
# │ 3   │ 2 Scales   │ 0.0173682 │ 0.0192129 │ 0.00605092 │ 0.0149015 │</code></pre><p>We can see that the accuracy of the simple method was particularly bad for <code>asset_2</code>.</p><p>This is due to microstructure noise which we can estimate as:</p><pre><code class="nohighlight hljs">noise          = estimate_microstructure_noise(ts, assets)</code></pre><p>And tabling the estimated and true microstructure noise we can see that there was more microstructure noise for <code>asset_2</code> relative to the other assets.</p><pre><code class="nohighlight hljs">using DataFrames
summary_frame = vcat(DataFrame.([true_micro_noise, noise] )... )
summary_frame = hcat(DataFrame(Dict(:estimation =&gt; [&quot;True&quot;, &quot;2 Scales noise estimate&quot;])), summary_frame)
print(summary_frame)
# 2×5 DataFrame
# │ Row │ estimation              │ asset_1    │ asset_2    │ asset_3     │ asset_4     │
# │     │ String                  │ Float64    │ Float64    │ Float64     │ Float64     │
# ├─────┼─────────────────────────┼────────────┼────────────┼─────────────┼─────────────┤
# │ 1   │ True                    │ 0.00216696 │ 0.0092135  │ 0.000226909 │ 0.000938589 │
# │ 2   │ 2 Scales noise estimate │ 0.0021294  │ 0.00854816 │ 0.000226053 │ 0.000871175 │</code></pre><h2 id="Estimating-a-covariance-matrix"><a class="docs-heading-anchor" href="#Estimating-a-covariance-matrix">Estimating a covariance matrix</a><a id="Estimating-a-covariance-matrix-1"></a><a class="docs-heading-anchor-permalink" href="#Estimating-a-covariance-matrix" title="Permalink"></a></h2><p>As this is a Monte Carlo we already have the true <code>CovarianceMatrix</code> in the <code>true_covar</code> variable. As we don&#39;t have this in applied settings we will disregard this for now and try to estimate it using our generated tick data stored in the <code>SortedDataFrame</code> with name <code>ts</code>:</p><pre><code class="nohighlight hljs">assets              = get_assets(ts)
simple_estimate     = estimate_covariance(ts, assets, :simple_covariance)
bnhls_estimate      = estimate_covariance(ts, assets, :bnhls_covariance)
spectral_estimate   = estimate_covariance(ts, assets, :spectral_covariance)
preav_estimate      = estimate_covariance(ts, assets, :preaveraged_covariance)
two_scales_estimate = estimate_covariance(ts, assets, :two_scales_covariance)</code></pre><p>We may alternatively use the functions corresponding to each method directly. This has the same result:</p><pre><code class="nohighlight hljs">bnhls_estimate2     = bnhls_covariance(ts, assets)
spectral_estimate2  = spectral_covariance(ts, assets)</code></pre><p>Now we may be particularly interested in one of the estimates, for instance the <code>bnhls_estimate</code>. We can first see if the correlation matrix it produces is valid (is positive semi-definite, has a unit diagonal and has all other entries below 1):</p><pre><code class="nohighlight hljs">valid_correlation_matrix(bnhls_estimate)
# true</code></pre><p>and fortunately it is. We could also examine the others similarly and see that they all deliver valid correlation matrices. One thing we might try then is to average over all of the more advanced methods and use the result as our correlation matrix estimate. This is easy to achieve by using the <code>combine_covariance_matrices</code> function.</p><pre><code class="nohighlight hljs">matrices = [spectral_estimate, preav_estimate, two_scales_estimate, bnhls_estimate]
combined_estimate = combine_covariance_matrices(matrices)</code></pre><p>Now we can compare how close each of the estimates is to the true correlation matrix. We can do this by examining the mean absolute difference between estimated correlations.</p><pre><code class="nohighlight hljs">calculate_mean_abs_distance(true_covar, combined_estimate)
# (Correlation_error = 0.38723691161754376, Volatility_error = 0.002500211816000063)
calculate_mean_abs_distance(true_covar, simple_estimate)
# (Correlation_error = 0.5321534542489482, Volatility_error = 0.010511960080115556)
calculate_mean_abs_distance(true_covar, bnhls_estimate)
# (Correlation_error = 0.7422120933301078, Volatility_error = 0.006815323622470541)
calculate_mean_abs_distance(true_covar, spectral_estimate)
# (Correlation_error = 0.5227424813357473, Volatility_error = 0.007669889385330695)
calculate_mean_abs_distance(true_covar, preav_estimate)
# (Correlation_error = 0.1840684108352901, Volatility_error = 0.0022421828719004925)
calculate_mean_abs_distance(true_covar, two_scales_estimate)
# (Correlation_error = 0.38238270061443486, Volatility_error = 0.0022421828719004925)</code></pre><p>We can see that in this particular case the correlation matrix calculated with the preaveraging method performed the best.</p><p>Now examining the data we can see that we have some assets that trade more frequently than the others.</p><pre><code class="nohighlight hljs">ticks_per_asset(ts)
# Dict{Symbol, Int64} with 4 entries:
#   :asset_4 =&gt; 3454
#   :asset_3 =&gt; 3242
#   :asset_2 =&gt; 1340
#   :asset_1 =&gt; 1964</code></pre><p>While we have 3454 price updates for <code>asset_4</code> we only have 1340 for <code>asset_2</code>. Potentially we could improve the bnhls estimate if we use a blocking and regularisation technique (Hautsch, Kyj and Oomen  2012).</p><p>We can start this by first making a <code>DataFrame</code> detailing what assets should be in what block. We will generate a new block if the minimum number of ticks of a new block has 20% more ticks than the minimum of the previous:</p><pre><code class="nohighlight hljs">new_block_threshold = 1.2
blocking_frame = put_assets_into_blocks_by_trading_frequency(
                        ts, new_block_threshold, :bnhls_covariance)</code></pre><p>This <code>blocking_frame</code> is a regular <code>DataFrame</code> with six columns where each row represents a different estimation. The order of the rows is the order of estimations (so the results of later estimations may overwrite earlier ones). The first column is named :assets and has the type <code>Set{Symbol}</code> which represents the assets in each estimation. The second column contains a symbol representing the function that will be used in the estimation of that block. The third column has the name :optional_parameters and is of type <code>NamedTuple</code> that can provide optional parameters to the covariance function in the second column. Every covariance estimation has a function signature with two common arguments before the semicolon (For a <code>SortedDataFrame</code> and a vector of symbols representing what assets to use). There can also be a number of named optional arguments which can be sourced from a <code>NamedTuple</code>. The <code>blockwise_estimation</code> function then estimates a block with the line</p><pre><code class="nohighlight hljs">blocking_frame[i,:f](ts, collect(blocking_frame[i,:assets]);
                     blocking_frame[i,:optional_parameters]... )</code></pre><p>Thus a user can insert a named tuple containing whatever optional parameters are used by the function.</p><p>The fourth, fifth and sixth columns contains the number of assets in the block, the mean number of ticks in the block and the mean time per tick. These do not do anything in the subsequent <code>blockwise_estimation</code> function but can be used to alter the <code>DataFrame</code>. Now in the current case we may decide to estimate the block containing all assets using the <code>spectral_covariance</code> method.</p><pre><code class="nohighlight hljs">one_asset_row = findall(blocking_frame[:,:number_of_assets] .== 4)
blocking_frame[one_asset_row, :f] = :spectral_covariance</code></pre><p>We can now estimate the blockwise estimated <code>CovarianceMatrix</code> as:</p><pre><code class="nohighlight hljs">block_estimate = blockwise_estimation(ts, blocking_frame)</code></pre><p>After a blockwise estimation the result may often not be PSD. So we could regularise at this point:</p><pre><code class="nohighlight hljs">reg_block_estimate = regularise(block_estimate , ts, :nearest_correlation_matrix)</code></pre><p>Finally we might seek to use one of our estimated <code>CovarianceMatrix</code>s to calculate an actual covariance matrix over some interval. This can be done with the code:</p><pre><code class="nohighlight hljs">covariance_interval = 1000
covar = covariance(combined_estimate, covariance_interval)</code></pre><p>Note that the time units of the covariance_interval here should be the same units as the <code>CovarianceMatrix</code> struct&#39;s volatility which are the same units as the time dimension in the <code>SortedDataFrame</code> that is used to estimate the <code>CovarianceMatrix</code>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../2_data_structures/">« Data Structures</a><a class="docs-footer-nextpage" href="../9_references/">References »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.7 on <span class="colophon-date" title="Wednesday 29 September 2021 11:21">Wednesday 29 September 2021</span>. Using Julia version 1.6.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Estimation Functions · HighFrequencyCovariance.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">HighFrequencyCovariance.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><span class="tocitem">First Steps with HighFrequencyCovariance.jl</span><ul><li><a class="tocitem" href="../1_algorithms/">Algorithms</a></li><li><a class="tocitem" href="../2_data_structures/">Data Structures</a></li><li><a class="tocitem" href="../3_WritingCode/">Writing Code</a></li><li><a class="tocitem" href="../9_references/">References</a></li></ul></li><li><span class="tocitem">Performance Comparison</span><ul><li><a class="tocitem" href="../4_performance_comparison/">Performance Comparison</a></li></ul></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="../types/">Types</a></li><li class="is-active"><a class="tocitem" href>Estimation Functions</a><ul class="internal"><li><a class="tocitem" href="#Estimating-Volatility"><span>Estimating Volatility</span></a></li><li><a class="tocitem" href="#Estimating-Microstructure-Noise"><span>Estimating Microstructure Noise</span></a></li><li><a class="tocitem" href="#Estimating-Covariance-Matrices"><span>Estimating Covariance Matrices</span></a></li><li><a class="tocitem" href="#Regularisation-of-Covariance-Matrices"><span>Regularisation of Covariance Matrices</span></a></li></ul></li><li><a class="tocitem" href="../helper_functions/">Helper Functions</a></li><li><a class="tocitem" href="../internals/">Internal Functions</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API</a></li><li class="is-active"><a href>Estimation Functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Estimation Functions</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/s-baumann/HighFrequencyCovariance.jl/blob/main/docs/src/functions.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Estimation-Functions"><a class="docs-heading-anchor" href="#Estimation-Functions">Estimation Functions</a><a id="Estimation-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Estimation-Functions" title="Permalink"></a></h1><ul><li><a href="#HighFrequencyCovariance.bnhls_covariance"><code>HighFrequencyCovariance.bnhls_covariance</code></a></li><li><a href="#HighFrequencyCovariance.eigenvalue_clean"><code>HighFrequencyCovariance.eigenvalue_clean</code></a></li><li><a href="#HighFrequencyCovariance.estimate_covariance"><code>HighFrequencyCovariance.estimate_covariance</code></a></li><li><a href="#HighFrequencyCovariance.estimate_microstructure_noise"><code>HighFrequencyCovariance.estimate_microstructure_noise</code></a></li><li><a href="#HighFrequencyCovariance.estimate_volatility"><code>HighFrequencyCovariance.estimate_volatility</code></a></li><li><a href="#HighFrequencyCovariance.identity_regularisation"><code>HighFrequencyCovariance.identity_regularisation</code></a></li><li><a href="#HighFrequencyCovariance.nearest_correlation_matrix"><code>HighFrequencyCovariance.nearest_correlation_matrix</code></a></li><li><a href="#HighFrequencyCovariance.nearest_psd_matrix"><code>HighFrequencyCovariance.nearest_psd_matrix</code></a></li><li><a href="#HighFrequencyCovariance.preaveraged_covariance"><code>HighFrequencyCovariance.preaveraged_covariance</code></a></li><li><a href="#HighFrequencyCovariance.regularise"><code>HighFrequencyCovariance.regularise</code></a></li><li><a href="#HighFrequencyCovariance.simple_covariance"><code>HighFrequencyCovariance.simple_covariance</code></a></li><li><a href="#HighFrequencyCovariance.simple_volatility"><code>HighFrequencyCovariance.simple_volatility</code></a></li><li><a href="#HighFrequencyCovariance.spectral_covariance"><code>HighFrequencyCovariance.spectral_covariance</code></a></li><li><a href="#HighFrequencyCovariance.two_scales_covariance"><code>HighFrequencyCovariance.two_scales_covariance</code></a></li><li><a href="#HighFrequencyCovariance.two_scales_volatility"><code>HighFrequencyCovariance.two_scales_volatility</code></a></li></ul><h2 id="Estimating-Volatility"><a class="docs-heading-anchor" href="#Estimating-Volatility">Estimating Volatility</a><a id="Estimating-Volatility-1"></a><a class="docs-heading-anchor-permalink" href="#Estimating-Volatility" title="Permalink"></a></h2><p>The <code>estimate_volatility</code> function is the main volatility estimation function. Either of the two estimation methods can be called by specifying <code>:simple_volatility</code> or <code>:two_scales_volatility</code> as the method argument in the <code>estimate_volatility</code> function. Alternatively the <code>simple_volatility</code> or <code>two_scales_volatility</code> functions can be called directly.</p><p>The <code>simple_volatility</code> returns a  <code>Dict</code> with the estimated volatility for each asset. The <code>two_scales_volatility</code> function on the other hand returns a tuple with a <code>Dict</code> of estimated volatilities in the first position and a <code>Dict</code> of estimated microstructure noise variances in the second. For uniformity of output the <code>estimate_volatility</code> returns a <code>Dict</code> with the estimated volatility for each asset regardless of what method is chosen.</p><p>If a user wants to calculate both volatilities and microstructure noises then they are advised to prefer the <code>two_scales_volatility</code> function over doing both <code>estimate_volatility</code> (with the <code>:two_scale_covariance</code> method argument) and the <code>estimate_microstructure_noise</code> function. While the results are the same doing the two function option means everything is calculated twice.</p><article class="docstring"><header><a class="docstring-binding" id="HighFrequencyCovariance.estimate_volatility" href="#HighFrequencyCovariance.estimate_volatility"><code>HighFrequencyCovariance.estimate_volatility</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">estimate_volatility(
    ts::SortedDataFrame,
    assets::Vector{Symbol} = get_assets(ts),
    method::Symbol = :two_scales_volatility;
    time_grid::Union{Missing,Dict} = missing,
    fixed_spacing::Union{Missing,Dict,&lt;:Real} = missing,
    use_all_obs::Bool = false,
    rough_guess_number_of_intervals::Integer = 5,
    num_grids::Real = default_num_grids(ts),
)</code></pre><p>This is a convenience wrapper for the two volatility estimation techniques included in this package.</p><p><strong>General Inputs</strong></p><ul><li><code>ts</code> - The tick data.</li><li><code>assets</code> - What assets from ts that you want to estimate the covariance for.</li><li><code>method</code> - The method can be <code>:simple_volatility</code> (for the simple volatility method) or <code>:two_scales_volatility</code> (for the two scales volatility method)</li></ul><p><strong>Inputs only used in <code>:simple_volatility</code> method.</strong></p><ul><li><code>time_grid</code> - The grid with which to calculate returns. If missing one is generated with a fixed spacing (if that is provided) or a default spacing.</li><li><code>fixed_spacing</code> - A spacing used to calculate a time grid. Not used if a <code>time_grid</code> is input or if <code>use_all_obs = true</code>.</li><li><code>use_all_obs</code> - Use all observations to estimate volatilities. Not used if a <code>time_grid</code> is provided.</li><li><code>rough_guess_number_of_intervals</code> - A rough number of intervals to calculate a default spacing. Not used if a <code>time_grid</code> or <code>fixed_spacing</code> is provided or if <code>use_all_obs = true</code>.</li></ul><p><strong>Inputs only used in <code>:two_scales_volatility</code> method.</strong></p><ul><li><code>num_grids</code> - Number of grids used in order in two scales estimation.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>Dict</code> with estimated volatilities for each asset.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/HighFrequencyCovariance.jl/blob/344244e398e843a3f2ade0f36a47b4a2ec408da1/src/50_ConvenienceFunctions.jl#L1-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HighFrequencyCovariance.simple_volatility" href="#HighFrequencyCovariance.simple_volatility"><code>HighFrequencyCovariance.simple_volatility</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">simple_volatility(
   ts::SortedDataFrame,
   assets::Vector{Symbol} = get_assets(ts);
   time_grid::Union{Missing,Dict} = missing,
   fixed_spacing::Union{Missing,Dict,&lt;:Real} = missing,
   use_all_obs::Bool = false,
   rough_guess_number_of_intervals::Integer = 5,
)</code></pre><p>Calculates volatility with the simple method.</p><p><strong>Inputs</strong></p><ul><li><code>ts</code> - The tick data.</li><li><code>assets</code> - The assets you want to estimate volatilities for.</li><li><code>time_grid</code> - The grid with which to calculate returns. If missing one is generated with a fixed spacing (if that is provided) or a default spacing.</li><li><code>fixed_spacing</code> - A spacing used to calculate a time grid. Not used if a <code>time_grid</code> is input or if <code>use_all_obs = true</code>.</li><li><code>use_all_obs</code> - Use all observations to estimate volatilities. Not used if a <code>time_grid</code> is provided.</li><li><code>rough_guess_number_of_intervals</code> - A rough number of intervals to calculate a default spacing. Not used if a <code>time_grid</code> or <code>fixed_spacing</code> is provided or if <code>use_all_obs = true</code>.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>Dict</code> with an estimated volatility for each asset.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/HighFrequencyCovariance.jl/blob/344244e398e843a3f2ade0f36a47b4a2ec408da1/src/10_volatility_simple.jl#L40-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HighFrequencyCovariance.two_scales_volatility" href="#HighFrequencyCovariance.two_scales_volatility"><code>HighFrequencyCovariance.two_scales_volatility</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">two_scales_volatility(vals::Vector, times::Vector, num_grids::Real)</code></pre><p>Calculates volatility with the two scales method of Zhang, Mykland, Ait-Sahalia 2005. The amount of time for the grid spacing is by default this is a tenth of the total duration by default. If this doesn&#39;t make sense for your use of it then choose a spacing at which you expect the effect of microstructure noise will be small.</p><p><strong>Inputs</strong></p><ul><li><code>vals</code> - The prices at each instant in time.</li><li><code>times</code> - The times corresponding to each element in <code>vals</code>.</li><li><code>num_grids</code> - Number of grids used in order in two scales estimation.</li></ul><p><strong>Returns</strong></p><ul><li><p>A scalar for the estimated volatility of the asset.</p></li><li><p>A scalar for the estimated microstructure noise variance.</p><p>two<em>scales</em>volatility(       ts::SortedDataFrame,       assets::Vector{Symbol} = get<em>assets(ts);       num</em>grids::Real = default<em>num</em>grids(ts),   )</p></li></ul><p>Calculates volatility with the two scales method of Zhang, Mykland, Ait-Sahalia 2005. The amount of time for the grid spacing is by default this is a tenth of the total duration by default. If this doesn&#39;t make sense for your use of it then choose a spacing at which you expect the effect of microstructure noise will be small.</p><p><strong>Inputs</strong></p><ul><li><code>ts</code> - The tick data.</li><li><code>assets</code> - The assets you want to estimate volatilities for.</li><li><code>num_grids</code> - Number of grids used in order in two scales estimation.</li></ul><p><strong>Returns</strong></p><ul><li>A  <code>Dict</code> with estimated volatilities for each asset.</li><li>A  <code>Dict</code> with estimated microstructure noise variances for each asset.</li></ul><p><strong>References</strong></p><p>Zhang L, Mykland PA, Aït-Sahalia Y (2005). &quot;A Tale of Two Time Scales: Determining Integrated Volatility with Noisy High-Frequency Data.&quot; Journal of the American Statistical Association, 100(472), 1394–1411. ISSN 01621459. doi:10.1198/016214505000000169.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/HighFrequencyCovariance.jl/blob/344244e398e843a3f2ade0f36a47b4a2ec408da1/src/11_volatility_two_scales.jl#L33-L64">source</a></section></article><h2 id="Estimating-Microstructure-Noise"><a class="docs-heading-anchor" href="#Estimating-Microstructure-Noise">Estimating Microstructure Noise</a><a id="Estimating-Microstructure-Noise-1"></a><a class="docs-heading-anchor-permalink" href="#Estimating-Microstructure-Noise" title="Permalink"></a></h2><p>There is one function that returns a <code>Dict</code> of microstructure noise estimates for each asset. These estimates come from the <code>two_scales_volatility</code> method and are identical to what you get if you examine the second element of the tuple that that function outputs.</p><article class="docstring"><header><a class="docstring-binding" id="HighFrequencyCovariance.estimate_microstructure_noise" href="#HighFrequencyCovariance.estimate_microstructure_noise"><code>HighFrequencyCovariance.estimate_microstructure_noise</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">estimate_microstructure_noise(
    ts::SortedDataFrame,
    assets::Vector{Symbol} = get_assets(ts);
    num_grids::Real = default_num_grids(ts),
)</code></pre><p>This estimates microstructure noise with the two<em>scales</em>volatility method.</p><p><strong>Inputs</strong></p><ul><li><code>ts</code> - The tick data.</li><li><code>assets</code> - What assets from ts that you want to estimate the covariance for.</li><li><code>num_grids</code> - Number of grids used in order in two scales estimation.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>Dict</code> with estimated microstructure noise variances for each asset.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/HighFrequencyCovariance.jl/blob/344244e398e843a3f2ade0f36a47b4a2ec408da1/src/50_ConvenienceFunctions.jl#L54-L68">source</a></section></article><h2 id="Estimating-Covariance-Matrices"><a class="docs-heading-anchor" href="#Estimating-Covariance-Matrices">Estimating Covariance Matrices</a><a id="Estimating-Covariance-Matrices-1"></a><a class="docs-heading-anchor-permalink" href="#Estimating-Covariance-Matrices" title="Permalink"></a></h2><p>The <code>estimate_covariance</code> is the main method for estimating a CovarianceMatrix. Five possible methods can be input to this function (or the functions for each method can alternatively be called directly).</p><p>All covariance estimation functions take in a <code>SortedDataFrame</code> and (optionally) a vector of symbol names representing assets and (optionally) a specified regularisation method. If the vector of symbol names for assets in input then the CovarianceMatrix will only include those input assets and assets will be in the order specified in the vector.</p><p>If the regularisation method is specified then this will be used in regularising the resulting matrix. This can alternatively be <code>missing</code> in which case no regularisation will be done. By default the <code>nearest_psd_matrix</code> will be used for every method except the <code>two_scales_covariance</code> method and this regularisation is done on the estimated covariance matrix before its correlation matrix and volatilities are split up and placed in a <code>CovarianceMatrix</code> struct. For the <code>two_scales_covariance</code> method the correlation matrix is estimated directly and regularisation is applied to this correlation matrix. Hence the <code>nearest_correlation_matrix</code> is the default.</p><p>Note that some combinations of estimation technique and regularisation technique will not work. For instance <code>nearest_correlation_matrix</code> would not be good to apply in the case of the <code>preaveraged_covariance</code> method as it would attempt to make a covariance matrix into a correlation matrix with a unit diagonal. In addition if the estimated matrix is very non-psd then heavy regularisation might be required. This may have bad results. In these cases it may be useful to turn off regularisation in the estimation function and instead apply regularisation to the <code>CovarianceMatrix</code> struct.</p><article class="docstring"><header><a class="docstring-binding" id="HighFrequencyCovariance.estimate_covariance" href="#HighFrequencyCovariance.estimate_covariance"><code>HighFrequencyCovariance.estimate_covariance</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">estimate_covariance(
    ts::SortedDataFrame,
    assets::Vector{Symbol} = get_assets(ts),
    method::Symbol = :preaveraged_covariance;
    regularisation::Union{Missing,Symbol} = :default,
    regularisation_params::Dict = Dict(),
    only_regulise_if_not_PSD::Bool = false,
    time_grid::Union{Missing,Vector} = missing,
    fixed_spacing::Union{Missing,&lt;:Real} = missing,
    refresh_times::Bool = false,
    rough_guess_number_of_intervals::Integer = 5, # General Inputs
    kernel::HFC_Kernel{&lt;:Real} = parzen,
    H::Real = kernel.c_star * mean(a -&gt; length(ts.groupingrows[a]), assets)^0.6,
    m::Integer = 2, # BNHLS parameters
    numJ::Integer = 100,
    num_blocks::Integer = 10,
    block_width::Real = (maximum(ts.df[:, ts.time]) - minimum(ts.df[:, ts.time])) /
                        num_blocks,
    microstructure_noise_var::Dict{Symbol,&lt;:Real} = two_scales_volatility(ts, assets)[2], # Spectral Covariance parameters
    drop_assets_if_not_enough_data::Bool = false,
    theta::Real = 0.15,
    g::NamedTuple = g, # Preaveraging
    equalweight::Bool = false,
    num_grids::Real = default_num_grids(ts),
    min_obs_for_estimation::Integer = 10,
    if_dont_have_min_obs::Real = NaN,
)</code></pre><p>This is a convenience wrapper for the regularisation techniques.</p><p><strong>General Inputs</strong></p><ul><li><code>ts</code> - The tick data.</li><li><code>assets</code> - What assets from ts that you want to estimate the covariance for.</li><li><code>method</code>  - The method you want to use. This can be <code>:simple_covariance</code>, <code>:bnhls_covariance</code>, <code>:spectral_covariance</code>, <code>:preaveraged_covariance</code> or <code>:two_scales_covariance</code>.</li><li><code>regularisation</code> - The regularisation method to use. This can be <code>:identity_regularisation</code>, <code>:eigenvalue_clean</code>, <code>:nearest_correlation_matrix</code> or <code>:nearest_psd_matrix</code>. You can also choose <code>:covariance_default</code> (which is <code>:nearest_psd_matrix</code>) or  <code>:correlation_default</code> (which is <code>:nearest_correlation_matrix</code>). If missing then the default regularisation method for your chosen covariance estimation method will be used.</li><li><code>regularisation_params</code> - Keyword arguments that will be used by your chosen regularisation method.</li><li><code>only_regulise_if_not_PSD</code> - Should the resultant matrix only be regularised if it is not psd.</li></ul><p><strong>Inputs only used in <code>:simple_covariance</code> method.</strong></p><ul><li><code>time_grid</code> - The grid with which to calculate returns (<code>:simple_covariance</code> method only).</li><li><code>fixed_spacing</code> - A spacing used to calculate a time grid. Not used if <code>refresh_times=true</code> (<code>:simple_covariance</code> method only).</li><li><code>refresh_times</code> - Should refresh times be used to estimate covariance (<code>:simple_covariance</code> method only).</li><li><code>rough_guess_number_of_intervals</code> - A rough number of intervals to calculate a default spacing. Not used if a <code>time_grid</code> or <code>fixed_spacing</code> is provided or if <code>refresh_times=true</code> (<code>:simple_covariance</code> method only).</li></ul><p><strong>Inputs only used in <code>:bnhls_covariance</code> method.</strong></p><ul><li><code>kernel</code> - The kernel used. See the bnhls paper for details. (<code>:bnhls_covariance</code> method only)</li><li><code>H</code> - The number of lags/leads used in estimation. See the bnhls paper for details. (<code>:bnhls_covariance</code> method only)</li><li><code>m</code> - The number of end returns to average. (<code>:bnhls_covariance</code> method only)</li></ul><p><strong>Inputs only used in <code>:spectral_covariance</code> method.</strong></p><ul><li><code>numJ</code> - The number of J values. See the paper for details (<code>:spectral_covariance</code> method only).</li><li><code>num_blocks</code> - The number of blocks to split the time frame into. See the preaveraging paper for details (<code>:spectral_covariance</code> method only).</li><li><code>block_width</code> - The width of each block to split the time frame into (<code>:spectral_covariance</code> method only).</li><li><code>microstructure_noise_var</code> - Estimates of microstructure noise variance for each asset (<code>:spectral_covariance</code> method only).</li></ul><p><strong>Inputs only used in <code>:preaveraged_covariance</code> method.</strong></p><ul><li><code>drop_assets_if_not_enough_data</code> - If we do not have enough data to estimate for all the input <code>assets</code> should we just calculate the correlation/volatilities for those assets we do have?</li><li><code>theta</code> - A theta value. See paper for details (<code>:preaveraged_covariance</code> method only).</li><li><code>g</code> - A tuple containing a preaveraging method (with name &quot;f&quot;) and a ψ value. See paper for details (<code>:preaveraged_covariance</code> method only).</li></ul><p><strong>Inputs only used in <code>:two_scales_covariance</code> method.</strong></p><ul><li><code>equalweight</code> - Should we use equal weight for the two different linear combinations of assets. If false then an optimal weight is calculated (from volatilities) (<code>:two_scales_covariance</code> method only).</li><li><code>num_grids</code> - Number of grids used in order in two scales estimation (<code>:two_scales_covariance</code> method only).</li><li><code>min_obs_for_estimation</code> - How many observations do we need for estimation. If less than this we use below fallback.</li><li><code>if_dont_have_min_obs</code> - If we do not have sufficient observations to estimate a correlation then what should be used?</li></ul><p><strong>Returns</strong></p><ul><li>A <code>CovarianceMatrix</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/HighFrequencyCovariance.jl/blob/344244e398e843a3f2ade0f36a47b4a2ec408da1/src/50_ConvenienceFunctions.jl#L77-L139">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HighFrequencyCovariance.simple_covariance" href="#HighFrequencyCovariance.simple_covariance"><code>HighFrequencyCovariance.simple_covariance</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">simple_covariance(
    ts::SortedDataFrame,
    assets::Vector{Symbol} = get_assets(ts);
    regularisation::Union{Missing,Symbol} = :covariance_default,
    regularisation_params::Dict = Dict(),
    only_regulise_if_not_PSD::Bool = false,
    time_grid::Union{Missing,Vector} = missing,
    fixed_spacing::Union{Missing,&lt;:Real} = missing,
    refresh_times::Bool = false,
    rough_guess_number_of_intervals::Integer = 5,
)</code></pre><p>Estimation of the covariance matrix in the standard textbook way.</p><p><strong>Inputs</strong></p><ul><li><code>ts</code> - The tick data.</li><li><code>assets</code> - The assets you want to estimate volatilities for.</li><li><code>regularisation</code> - A symbol representing what regularisation technique should be used. If missing no regularisation is performed.</li><li><code>regularisation_params</code> - keyword arguments to be consumed in the regularisation algorithm.</li><li><code>only_regulise_if_not_PSD</code> - Should regularisation only be attempted if the matrix is not psd already.</li><li><code>time_grid</code> - The grid with which to calculate returns.</li><li><code>fixed_spacing</code> - A spacing used to calculate a time grid. Not used if <code>refresh_times=true</code>.</li><li><code>refresh_times</code> - Should refresh times be used to estimate covariance.</li><li><code>rough_guess_number_of_intervals</code> - A rough number of intervals to calculate a default spacing. Not used if a <code>time_grid</code> or <code>fixed_spacing</code> is provided or if <code>refresh_times=true</code>.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>CovarianceMatrix</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/HighFrequencyCovariance.jl/blob/344244e398e843a3f2ade0f36a47b4a2ec408da1/src/20_covariance_simple.jl#L71-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HighFrequencyCovariance.bnhls_covariance" href="#HighFrequencyCovariance.bnhls_covariance"><code>HighFrequencyCovariance.bnhls_covariance</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">bnhls_covariance(
    ts::SortedDataFrame,
    assets::Vector{Symbol} = get_assets(ts);
    regularisation::Union{Missing,Symbol} = :covariance_default,
    regularisation_params::Dict = Dict(),
    only_regulise_if_not_PSD::Bool = false,
    kernel::HFC_Kernel{&lt;:Real} = parzen,
    H::Real = kernel.c_star * (mean(map(a -&gt; length(ts.groupingrows[a]), assets)))^0.6,
    m::Integer = 2,
)</code></pre><p>This calculates covariance with the Multivariate realised kernel oof BNHLS(2011).</p><p><strong>Inputs</strong></p><ul><li><code>ts</code> - The tick data.</li><li><code>assets</code> - The assets you want to estimate volatilities for.</li><li><code>regularisation</code> - A symbol representing what regularisation technique should be used. If missing no regularisation is performed.</li><li><code>regularisation_params</code> - keyword arguments to be consumed in the regularisation algorithm.</li><li><code>only_regulise_if_not_PSD</code> - Should regularisation only be attempted if the matrix is not psd already.</li><li><code>kernel</code> - The kernel used. See the paper for details.</li><li><code>H</code> - The number of lags/leads used in estimation. See the paper for details.</li><li><code>m</code> - The number of end returns to average.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>CovarianceMatrix</code>.</li></ul><p><strong>References</strong></p><p>Barndorff-Nielsen, O., Hansen, P.R., Lunde, A., Shephard, N. 2011. - The whole paper but particularly 2.2, 2.3 here. Kernels are in table 1. choices of H are discussed in section 3.4 of the paper.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/HighFrequencyCovariance.jl/blob/344244e398e843a3f2ade0f36a47b4a2ec408da1/src/21_covariance_bnhls.jl#L136-L163">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HighFrequencyCovariance.spectral_covariance" href="#HighFrequencyCovariance.spectral_covariance"><code>HighFrequencyCovariance.spectral_covariance</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">spectral_covariance(
    ts::SortedDataFrame,
    assets::Vector{Symbol} = get_assets(ts);
    regularisation::Union{Missing,Symbol} = :covariance_default,
    regularisation_params::Dict = Dict(),
    only_regulise_if_not_PSD::Bool = false,
    numJ::Integer = 100,
    num_blocks::Integer = 10,
    block_width::Real = (maximum(ts.df[:, ts.time]) - minimum(ts.df[:, ts.time])) /
                        num_blocks,
    microstructure_noise_var::Dict{Symbol,&lt;:Real} = two_scales_volatility(ts, assets)[2],
)</code></pre><p>Estimation of a CovarianceMatrix using the spectral covariance method.</p><p><strong>Inputs</strong></p><ul><li><code>ts</code> - The tick data.</li><li><code>assets</code> - The assets you want to estimate volatilities for.</li><li><code>regularisation</code> - A symbol representing what regularisation technique should be used. If missing no regularisation is performed.</li><li><code>regularisation_params</code> - keyword arguments to be consumed in the regularisation algorithm.</li><li><code>only_regulise_if_not_PSD</code> - Should regularisation only be attempted if the matrix is not psd already.</li><li><code>numJ</code> - The number of J values. See the paper for details.</li><li><code>num_blocks</code> - The number of blocks to split the time frame into. See the paper for details.</li><li><code>block_width</code> - The width of each block to split the time frame into.</li><li><code>microstructure_noise_var</code> - Estimates of microstructure noise variance for each asset.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>CovarianceMatrix</code>.</li></ul><p><strong>References</strong></p><p>Bibinger M, Hautsch N, Malec P, Reiss M (2014). “Estimating the quadratic covariation matrix from noisy observations: Local method of moments and efficiency.” The Annals of Statistics, 42(4), 1312–1346. doi:10.1214/14-AOS1224.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/HighFrequencyCovariance.jl/blob/344244e398e843a3f2ade0f36a47b4a2ec408da1/src/22_covariance_spectral.jl#L143-L173">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HighFrequencyCovariance.preaveraged_covariance" href="#HighFrequencyCovariance.preaveraged_covariance"><code>HighFrequencyCovariance.preaveraged_covariance</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">preaveraged_covariance(
    ts::SortedDataFrame,
    assets::Vector{Symbol} = get_assets(ts);
    regularisation::Union{Missing,Symbol} = :covariance_default,
    drop_assets_if_not_enough_data::Bool = false,
    regularisation_params::Dict = Dict(),
    only_regulise_if_not_PSD::Bool = false,
    theta::Real = 0.15,
    g::NamedTuple = g,
)</code></pre><p>Estimation of the CovarianceMatrix using preaveraging method.</p><p><strong>Inputs</strong></p><ul><li><code>ts</code> - The tick data.</li><li><code>assets</code> - The assets you want to estimate volatilities for.</li><li><code>regularisation</code> - A symbol representing what regularisation technique should be used. If missing no regularisation is performed.</li><li><code>drop_assets_if_not_enough_data</code> - If we do not have enough data to estimate for all the input <code>assets</code> should we just calculate the correlation/volatilities for those assets we do have?</li><li><code>regularisation_params</code> - keyword arguments to be consumed in the regularisation algorithm.</li><li><code>only_regulise_if_not_PSD</code> - Should regularisation only be attempted if the matrix is not psd already.</li><li><code>theta</code> - A theta value. See paper for details.</li><li><code>g</code> - A tuple containing a preaveraging method function (with name &quot;f&quot;) and a ψ (with name &quot;psi&quot;) value.   psi here should be the integral of the function over the interval between zero and one.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>CovarianceMatrix</code>.</li></ul><p><strong>References</strong></p><p>Christensen K, Podolskij M, Vetter M (2013). “On covariation estimation for multivariate continuous Itô semimartingales with noise in non-synchronous observation schemes.” Journal of Multivariate Analysis, 120, 59–84. doi:10.1016/j.jmva.2013.05.002.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/HighFrequencyCovariance.jl/blob/344244e398e843a3f2ade0f36a47b4a2ec408da1/src/23_covariance_preaveragingHY.jl#L81-L109">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HighFrequencyCovariance.two_scales_covariance" href="#HighFrequencyCovariance.two_scales_covariance"><code>HighFrequencyCovariance.two_scales_covariance</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">two_scales_covariance(
    ts::SortedDataFrame,
    assets::Vector{Symbol} = get_assets(ts);
    regularisation::Union{Missing,Symbol} = :correlation_default,
    regularisation_params::Dict = Dict(),
    only_regulise_if_not_PSD::Bool = false,
    equalweight::Bool = false,
    num_grids::Real = default_num_grids(ts),
    min_obs_for_estimation::Integer = 10,
    if_dont_have_min_obs::Real = NaN,
)</code></pre><p>Estimation of a CovarianceMatrix using the two scale covariance method.</p><p><strong>Inputs</strong></p><ul><li><code>ts</code> - The tick data.</li><li><code>assets</code> - The assets you want to estimate volatilities for.</li><li><code>regularisation</code> - A symbol representing what regularisation technique should be used. If missing no regularisation is performed.</li><li><code>regularisation_params</code> - keyword arguments to be consumed in the regularisation algorithm.</li><li><code>only_regulise_if_not_PSD</code> - Should regularisation only be attempted if the matrix is not psd already.</li><li><code>equalweight</code> - Should we use equal weight for the two different linear combinations of assets. If false then an optimal weight is calculated (from volatilities).</li><li><code>num_grids</code> - Number of grids used in order in two scales estimation.</li><li><code>min_obs_for_estimation</code> - How many observations do we need for estimation. If less than this we use below fallback.</li><li><code>if_dont_have_min_obs</code> - If we do not have sufficient observations to estimate a correlation then what should be used?</li></ul><p><strong>Returns</strong></p><ul><li>A <code>CovarianceMatrix</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/HighFrequencyCovariance.jl/blob/344244e398e843a3f2ade0f36a47b4a2ec408da1/src/24_covariance_two_scales.jl#L67-L93">source</a></section></article><h2 id="Regularisation-of-Covariance-Matrices"><a class="docs-heading-anchor" href="#Regularisation-of-Covariance-Matrices">Regularisation of Covariance Matrices</a><a id="Regularisation-of-Covariance-Matrices-1"></a><a class="docs-heading-anchor-permalink" href="#Regularisation-of-Covariance-Matrices" title="Permalink"></a></h2><p>The main function for regularisation is the <code>regularise</code> function. In addition four methods are implemented for regularising matrices can be used directly or through the <code>regularise</code> function. All of these functions can be applied to either a <code>Hermitian</code> matrix or to a <code>CovarianceMatrix</code> struct.</p><p>If these functions are applied to a <code>Hermitian</code> then regularisation is applied and a regularised <code>Hermitian</code> is returned.</p><p>If these functions are applied to a <code>CovarianceMatrix</code> struct.</p><article class="docstring"><header><a class="docstring-binding" id="HighFrequencyCovariance.regularise" href="#HighFrequencyCovariance.regularise"><code>HighFrequencyCovariance.regularise</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">regularise(
    mat::Hermitian,
    ts::SortedDataFrame,
    mat_labels::Vector,
    method::Symbol = :correlation_default;
    spacing::Union{Missing,&lt;:Real} = missing,
    weighting_matrix = Diagonal(eltype(mat).(I(size(mat)[1]))),
    doDykstra = true,
    stop_at_first_correlation_matrix = true,
    max_iterates = 1000,
)</code></pre><p>This is a convenience wrapper for the regularisation techniques.</p><p><strong>General Inputs</strong></p><ul><li><code>mat</code> - The matrix you want to regularise.</li><li><code>ts</code> - The tick data.</li><li><code>mat_labels</code> - The name of the assets for each row/column of the matrix.</li><li><code>method</code>  - The method you want to use. This can be <code>:identity_regularisation</code>, <code>:eigenvalue_clean</code>, <code>:nearest_correlation_matrix</code> or <code>:nearest_psd_matrix</code>. You can also choose <code>:covariance_default</code> (which is <code>:nearest_psd_matrix</code>) or  <code>:correlation_default</code> (which is <code>:nearest_correlation_matrix</code>).</li></ul><p><strong>Inputs only used in <code>:identity_regularisation</code> method.</strong></p><ul><li><code>spacing</code> - The interval spacing used in choosing an identity weight (<code>identity_regularisation</code> method only).</li></ul><p><strong>Inputs only used in <code>:nearest_correlation_matrix</code> method.</strong></p><ul><li><code>weighting_matrix</code> - The weighting matrix used to calculate the nearest psd matrix (<code>:nearest_correlation_matrix</code> method only).</li><li><code>doDykstra</code> - Should a Dykstra correction be applied (<code>:nearest_correlation_matrix</code> method only).</li><li><code>stop_at_first_correlation_matrix</code> - Should we stop at first valid correlation matrix (<code>:nearest_correlation_matrix</code> method only).</li><li><code>max_iterates</code> - Maximum number of iterates (<code>:nearest_correlation_matrix</code> method only).</li></ul><p><strong>Returns</strong></p><ul><li><p>A <code>Hermitian</code></p><p>regularise(      covariance<em>matrix::CovarianceMatrix,      ts::SortedDataFrame,      method::Symbol = :nearest</em>correlation<em>matrix;      apply</em>to<em>covariance::Bool = true,      spacing::Union{Missing,&lt;:Real} = missing,      weighting</em>matrix = Diagonal(eltype(covariance<em>matrix.correlation).(I(size(covariance</em>matrix.correlation)[1]))),      doDykstra = true,      stop<em>at</em>first<em>correlation</em>matrix = true,      max_iterates = 1000,   )</p></li></ul><p>This is a convenience wrapper for the regularisation techniques.</p><p><strong>General Inputs</strong></p><ul><li><code>covariance_matrix</code> - The matrix you want to regularise.</li><li><code>ts</code> - The tick data.</li><li><code>method</code>  - The method you want to use. This can be <code>:identity_regularisation</code>, <code>:eigenvalue_clean</code>, <code>:nearest_correlation_matrix</code> or <code>:nearest_psd_matrix</code>. You can also choose <code>:covariance_default</code> (which is <code>:nearest_psd_matrix</code>) or  <code>:correlation_default</code> (which is <code>:nearest_correlation_matrix</code>).</li><li><code>apply_to_covariance</code> - Should regularisation be applied to the covariance matrix. If false it is applied to the correlation matrix.</li></ul><p><strong>Inputs only used in <code>:identity_regularisation</code> method.</strong></p><ul><li><code>spacing</code> - The interval spacing used in choosing an identity weight (<code>identity_regularisation</code> method only).</li></ul><p><strong>Inputs only used in <code>:nearest_correlation_matrix</code> method.</strong></p><ul><li><code>weighting_matrix</code> - The weighting matrix used to calculate the nearest psd matrix (<code>:nearest_correlation_matrix</code> method only).</li><li><code>doDykstra</code> - Should a Dykstra correction be applied (<code>:nearest_correlation_matrix</code> method only).</li><li><code>stop_at_first_correlation_matrix</code> - Should we stop at first valid correlation matrix (<code>:nearest_correlation_matrix</code> method only).</li><li><code>max_iterates</code> - Maximum number of iterates (<code>:nearest_correlation_matrix</code> method only).</li></ul><p><strong>Returns</strong></p><ul><li>A <code>CovarianceMatrix</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/HighFrequencyCovariance.jl/blob/344244e398e843a3f2ade0f36a47b4a2ec408da1/src/50_ConvenienceFunctions.jl#L231-L287">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HighFrequencyCovariance.identity_regularisation" href="#HighFrequencyCovariance.identity_regularisation"><code>HighFrequencyCovariance.identity_regularisation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">identity_regularisation(mat::Hermitian, identity_weight::Real)</code></pre><p>Regularisation of the correlation matrix by mixing with the identity matrix.</p><p><strong>Inputs</strong></p><ul><li><code>mat</code> - A matrix to be regularised.</li><li><code>identity_weight</code> - How much weight to give to the identity matrix. Should be between 0 and 1.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>Hermitian</code>.</li></ul><pre><code class="nohighlight hljs">identity_regularisation(mat::Hermitian, asset_returns::DataFrame)</code></pre><p>Regularisation of the correlation matrix by mixing with the identity matrix as per Ledoit &amp; Wolf 2003.</p><p><strong>Inputs</strong></p><ul><li><code>mat</code> - A matrix to be regularised.</li><li><code>ts</code> - Tick data.</li></ul><p><strong>Returns</strong></p><ul><li><p>A <code>Hermitian</code>.</p><p>identity<em>regularisation(       mat::Hermitian,       ts::SortedDataFrame,       mat</em>labels::Vector;       spacing::Union{Missing,&lt;:Real} = missing,   )</p></li></ul><p>Regularisation of the correlation matrix by mixing with the identity matrix as per Ledoit &amp; Wolf 2003.</p><p><strong>Inputs</strong></p><ul><li><code>mat</code> - A matrix to be regularised.</li><li><code>ts</code> - Tick data.</li><li><code>mat_labels</code> - The labels for each asset in the matrix.</li><li><code>spacing</code> A spacing to use to estimate returns. This is used in determining the optimal weight to give to the identity matrix.</li></ul><p><strong>Returns</strong></p><ul><li><p>A <code>Hermitian</code>.</p><p>identity<em>regularisation(       covariance</em>matrix::CovarianceMatrix,       ts::SortedDataFrame;       spacing::Union{Missing,&lt;:Real} = missing,       apply<em>to</em>covariance::Bool = true,   )</p></li></ul><p>Regularisation of the correlation matrix by mixing with the identity matrix as per Ledoit &amp; Wolf 2003.</p><p><strong>Inputs</strong></p><ul><li><code>covariance_matrix</code> - The <code>CovarianceMatrix</code> to be regularised.</li><li><code>ts</code> - Tick data.</li><li><code>spacing</code> A spacing to use to estimate returns. This is used in determining the optimal weight to give to the identity matrix.</li><li><code>apply_to_covariance</code> Should regularisation be applied to the covariance matrix or the correlation matrix.</li></ul><p><strong>Returns</strong></p><ul><li><p>A <code>CovarianceMatrix</code>.</p><p>identity<em>regularisation(       covariance</em>matrix::CovarianceMatrix,       identity<em>weight::Real;       apply</em>to_covariance = false,   )</p></li></ul><p>Regularisation of the correlation matrix by mixing with the identity matrix.</p><p><strong>Inputs</strong></p><ul><li><code>covariance_matrix</code> - The <code>CovarianceMatrix</code> to be regularised.</li><li><code>identity_weight</code> - How much weight to give to the identity matrix. Should be between 0 and 1.</li><li><code>apply_to_covariance</code> Should regularisation be applied to the covariance matrix or the correlation matrix.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>CovarianceMatrix</code>.</li></ul><p><strong>References</strong></p><p>Ledoit, O. , Wolf, M. 2003. Improved Estimation of the Covariance Matrix of Stock Returns with an application to portfolio selection. Journal of empirical finance. 10. 603-621.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/HighFrequencyCovariance.jl/blob/344244e398e843a3f2ade0f36a47b4a2ec408da1/src/30_Regularisation_identity.jl#L33-L101">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HighFrequencyCovariance.eigenvalue_clean" href="#HighFrequencyCovariance.eigenvalue_clean"><code>HighFrequencyCovariance.eigenvalue_clean</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">eigenvalue_clean(
    eigenvalues::Vector{&lt;:Real},
    eigenvectors::Matrix{&lt;:Real},
    eigenvalue_threshold::Real,
)</code></pre><p>This takes the small eigenvalues (with values below eigenvalue<em>threshold). It sets them to the greater of their average or eigenvalue</em>threshold/(4*number<em>of</em>small_eigens). Then the matrix is reconstructed and returned (as a <code>Hermitian</code>)</p><p><strong>Inputs</strong></p><ul><li><code>eigenvalues</code> - The eigenvalues of a matrix.</li><li><code>eigenvectors</code> - The eigenvectors  of a matrix.</li><li><code>eigenvalue_threshold</code> - The threshold for a eigenvalue to be altered.</li></ul><p><strong>Returns</strong></p><ul><li><p>A <code>Hermitian</code>.</p><p>eigenvalue<em>clean(mat::Hermitian, eigenvalue</em>threshold::Real)</p></li></ul><p>This splits a matrix into its eigenvalues and eigenvectors. Then takes the small eigenvalues (with values below <code>eigenvalue_threshold</code>). It sets them to the greater of their average or <code>eigenvalue_threshold/(4*number_of_small_eigens)</code>. Then the matrix is reconstructed and returned (as a <code>Hermitian</code>)</p><p><strong>Inputs</strong></p><ul><li><code>mat</code> - A matrix that you want to regularise with eigenvalue regularisation.</li><li><code>eigenvalue_threshold</code> - The threshold for a eigenvalue to be altered.</li></ul><p><strong>Returns</strong></p><ul><li><p>A <code>Hermitian</code>.</p><p>eigenvalue_clean(mat::Hermitian, ts::SortedDataFrame)</p></li></ul><p>Similarly to the above two methods these functions regularise a matrix by setting small eigenvalues to near zero. The method of Laloux, Cizeau, Bouchaud &amp; Potters 2000 is used to choose a threshold.</p><p><strong>Inputs</strong></p><ul><li><code>mat</code> - A matrix that you want to regularise with eigenvalue regularisation.</li><li><code>ts</code> - The tick data.</li></ul><p><strong>Returns</strong></p><ul><li><p>A <code>Hermitian</code>.</p><p>eigenvalue<em>clean(       covariance</em>matrix::CovarianceMatrix,       ts::SortedDataFrame;       apply<em>to</em>covariance::Bool = true,   )</p></li></ul><p><strong>Inputs</strong></p><ul><li><code>mat</code> - A matrix that you want to regularise with eigenvalue regularisation.</li><li><code>ts</code> - The tick data.</li><li><code>apply_to_covariance</code> Should regularisation be applied to the covariance matrix or the correlation matrix.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>CovarianceMatrix</code>.</li></ul><p>Note that if the input matrices include any NaN terms then regularisation is not possible. The matrix will be silently returned (as these NaNs will generally be from upstream problems so it is useful to return the matrix rather than throw at this point).As a result outputs should be checked.</p><p><strong>References</strong></p><p>Laloux, L., Cizeau, P., Bouchaud J. , Potters, M. 2000. &quot;Random matrix theory and financial correlations&quot; International Journal of Theoretical Applied FInance, 3, 391-397.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/HighFrequencyCovariance.jl/blob/344244e398e843a3f2ade0f36a47b4a2ec408da1/src/32_Regularisation_RMT.jl#L31-L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HighFrequencyCovariance.nearest_psd_matrix" href="#HighFrequencyCovariance.nearest_psd_matrix"><code>HighFrequencyCovariance.nearest_psd_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">nearest_psd_matrix(mat::Hermitian)</code></pre><p>This function maps a Hermitian matrix to the nearest psd matrix. This uses the <code>project_to_S</code> method in Higham (2001; Theorem 3.2). No special weighting is applied in this case. Advanced users can use the <code>project_to_S</code> directly if they want to use weights in order to decide what the <code>closest</code> pds matrix.</p><p><strong>Inputs</strong></p><ul><li><code>mat</code> - The matrix you want to map to a psd matrix</li></ul><p><strong>Results</strong></p><ul><li><p>A <code>Hermitian</code></p><p>nearest<em>psd</em>matrix(       covariance<em>matrix::CovarianceMatrix;       apply</em>to_covariance::Bool = true,   )</p></li></ul><p>This function maps a Hermitian matrix to the nearest psd matrix. This uses the <code>project_to_S</code> method in Higham (2001; Theorem 3.2). No special weighting is applied in this case. Advanced users can use the <code>project_to_S</code> directly if they want to use weights in order to decide what the <code>closest</code> pds matrix.</p><p><strong>Inputs</strong></p><ul><li><code>covariance_matrix</code> - The matrix you want to map to a psd matrix</li><li><code>apply_to_covariance</code> - Should regularisation be applied to the correlation or covariance matrix.</li></ul><p><strong>Results</strong></p><ul><li><p>A <code>CovarianceMatrix</code></p><p>nearest<em>psd</em>matrix(       covariance<em>matrix::CovarianceMatrix,       ts::SortedDataFrame;       apply</em>to_covariance::Bool = true,   )</p></li></ul><p>This function maps a Hermitian matrix to the nearest psd matrix. This uses the <code>project_to_S</code> method in Higham (2001; Theorem 3.2). No special weighting is applied in this case. Advanced users can use the <code>project_to_S</code> directly if they want to use weights in order to decide what the <code>closest</code> pds matrix.</p><p><strong>Inputs</strong></p><ul><li><code>covariance_matrix</code> - The matrix you want to map to a psd matrix</li><li><code>ts</code> - The Tick data</li><li><code>apply_to_covariance</code> - Should regularisation be applied to the correlation or covariance matrix.</li></ul><p><strong>Results</strong></p><ul><li>A <code>CovarianceMatrix</code></li></ul><p><strong>References</strong></p><p>Higham NJ (2002). &quot;Computing the nearest correlation matrix - a problem from finance.&quot; IMA Journal of Numerical Analysis, 22, 329–343. doi:10.1002/nla.258.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/HighFrequencyCovariance.jl/blob/344244e398e843a3f2ade0f36a47b4a2ec408da1/src/31_Regularisation_NearestCorrelationMatrix.jl#L349-L395">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HighFrequencyCovariance.nearest_correlation_matrix" href="#HighFrequencyCovariance.nearest_correlation_matrix"><code>HighFrequencyCovariance.nearest_correlation_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">nearest_correlation_matrix(
    mat::AbstractMatrix,
    weighting_matrix::Union{Diagonal,Hermitian} = Diagonal(Float64.(I(size(mat)[1])));
    doDykstra::Bool = true,
    stop_at_first_correlation_matrix::Bool = true,
    max_iterates::Integer = 1000,
)</code></pre><p>Maps a matrix to the nearest valid correlation matrix (pdf matrix with unit diagonal and all other entries below 1 in absolute value).</p><p><strong>Inputs</strong></p><ul><li><code>mat</code> - A matrix you want to regularise.</li><li><code>ts</code> - The tick data.</li><li><code>weighting_matrix</code> - The weighting matrix used to weight what the <strong>nearest</strong> valid correlation matrix is.</li><li><code>doDykstra</code> - Should Dykstra correction be done.</li><li><code>stop_at_first_correlation_matrix</code> - Should we keep iterating until we have done all iterates or stop at the first valid correlation matrix.</li><li><code>max_iterates</code> - The maximum number of iterates to do towards a valid correlation matrix.</li></ul><p><strong>Returns</strong></p><ul><li><p>A <code>Matrix</code></p></li><li><p>An integer saying how many iterates were done</p></li><li><p>A Symbol with a convergence message.</p><p>nearest<em>correlation</em>matrix(       covariance<em>matrix::CovarianceMatrix,       ts::SortedDataFrame;       weighting</em>matrix::Union{Diagonal,Hermitian} = Diagonal(eltype(covariance<em>matrix.correlation).(I(size(covariance</em>matrix.correlation)[1]))),       doDykstra::Bool = true,       stop<em>at</em>first<em>correlation</em>matrix::Bool = true,       max_iterates::Integer = 1000,   )</p></li></ul><p>Maps a matrix to the nearest valid correlation matrix (pdf matrix with unit diagonal and all other entries below 1 in absolute value).</p><p><strong>Inputs</strong></p><ul><li><code>covariance_matrix</code> - The matrix you want to regularise.</li><li><code>ts</code> - The tick data.</li><li><code>weighting_matrix</code> - The weighting matrix used to weight what the <strong>nearest</strong> valid correlation matrix is.</li><li><code>doDykstra</code> - Should Dykstra correction be done.</li><li><code>stop_at_first_correlation_matrix</code> - Should we keep iterating until we have done all iterates or stop at the first valid correlation matrix.</li><li><code>max_iterates</code> - The maximum number of iterates to do towards a valid correlation matrix.</li></ul><p><strong>Returns</strong></p><ul><li><p>A <code>CovarianceMatrix</code></p><p>nearest<em>correlation</em>matrix(       covariance<em>matrix::CovarianceMatrix;       weighting</em>matrix::Union{Diagonal,Hermitian} = Diagonal(eltype(covariance<em>matrix.correlation).(I(size(covariance</em>matrix.correlation)[1]))),       doDykstra::Bool = true,       stop<em>at</em>first<em>correlation</em>matrix::Bool = true,       max_iterates::Integer = 1000,   )</p></li></ul><p>Maps a matrix to the nearest valid correlation matrix (pdf matrix with unit diagonal and all other entries below 1 in absolute value).</p><p><strong>Inputs</strong></p><ul><li><code>covariance_matrix</code> - The matrix you want to regularise.</li><li><code>weighting_matrix</code> - The weighting matrix used to weight what the <strong>nearest</strong> valid correlation matrix is.</li><li><code>doDykstra</code> - Should Dykstra correction be done.</li><li><code>stop_at_first_correlation_matrix</code> - Should we keep iterating until we have done all iterates or stop at the first valid correlation matrix.</li><li><code>max_iterates</code> - The maximum number of iterates to do towards a valid correlation matrix.</li></ul><p><strong>Returns</strong></p><ul><li><p>A <code>CovarianceMatrix</code></p><p>nearest<em>correlation</em>matrix(       mat::Hermitian,       ts::SortedDataFrame;       weighting<em>matrix::Union{Diagonal,Hermitian} = Diagonal(eltype(mat).(I(size(mat)[1]))),       doDykstra::Bool = true,       stop</em>at<em>first</em>correlation<em>matrix::Bool = true,       max</em>iterates::Integer = 1000,   )</p></li></ul><p>Maps a matrix to the nearest valid correlation matrix (pdf matrix with unit diagonal and all other entries below 1 in absolute value).</p><p><strong>Inputs</strong></p><ul><li><code>mat</code> - The matrix you want to regularise.</li><li><code>weighting_matrix</code> - The weighting matrix used to weight what the <strong>nearest</strong> valid correlation matrix is.</li><li><code>doDykstra</code> - Should Dykstra correction be done.</li><li><code>stop_at_first_correlation_matrix</code> - Should we keep iterating until we have done all iterates or stop at the first valid correlation matrix.</li><li><code>max_iterates</code> - The maximum number of iterates to do towards a valid correlation matrix.</li></ul><p><strong>Returns</strong></p><ul><li><p>A <code>Hermitian</code></p><p>nearest<em>correlation</em>matrix(      mat::Hermitian;      weighting<em>matrix::Union{Diagonal,Hermitian} = Diagonal(eltype(mat).(I(size(mat)[1]))),      doDykstra::Bool = true,      stop</em>at<em>first</em>correlation<em>matrix::Bool = true,      max</em>iterates::Integer = 1000,   )</p></li></ul><p>Maps a matrix to the nearest valid correlation matrix (pdf matrix with unit diagonal and all other entries below 1 in absolute value).</p><p><strong>Inputs</strong></p><ul><li><code>covariance_matrix</code> - The matrix you want to regularise.</li><li><code>ts</code> - The tick data.</li><li><code>weighting_matrix</code> - The weighting matrix used to weight what the <strong>nearest</strong> valid correlation matrix is.</li><li><code>doDykstra</code> - Should Dykstra correction be done.</li><li><code>stop_at_first_correlation_matrix</code> - Should we keep iterating until we have done all iterates or stop at the first valid correlation matrix.</li><li><code>max_iterates</code> - The maximum number of iterates to do towards a valid correlation matrix.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>Hermitian</code></li></ul><p><strong>References</strong></p><p>Higham NJ (2002). &quot;Computing the nearest correlation matrix - a problem from finance.&quot; IMA Journal of Numerical Analysis, 22, 329–343. doi:10.1002/nla.258.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/HighFrequencyCovariance.jl/blob/344244e398e843a3f2ade0f36a47b4a2ec408da1/src/31_Regularisation_NearestCorrelationMatrix.jl#L148-L248">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../types/">« Types</a><a class="docs-footer-nextpage" href="../helper_functions/">Helper Functions »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Sunday 1 June 2025 05:45">Sunday 1 June 2025</span>. Using Julia version 1.10.9.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

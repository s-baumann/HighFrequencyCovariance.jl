<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Estimation Functions · HighFrequencyCovariance.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">HighFrequencyCovariance.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><span class="tocitem">First Steps with HighFrequencyCovariance.jl</span><ul><li><a class="tocitem" href="../1_algorithms/">Algorithms</a></li><li><a class="tocitem" href="../2_data_structures/">Data Structures</a></li><li><a class="tocitem" href="../3_WritingCode/">Writing Code</a></li><li><a class="tocitem" href="../9_references/">References</a></li></ul></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="../types/">Types</a></li><li class="is-active"><a class="tocitem" href>Estimation Functions</a><ul class="internal"><li><a class="tocitem" href="#Estimating-Volatility"><span>Estimating Volatility</span></a></li><li><a class="tocitem" href="#Estimating-Microstructure-Noise"><span>Estimating Microstructure Noise</span></a></li><li><a class="tocitem" href="#Estimating-Covariance-Matrices"><span>Estimating Covariance Matrices</span></a></li><li><a class="tocitem" href="#Regularisation-of-Covariance-Matrices"><span>Regularisation of Covariance Matrices</span></a></li></ul></li><li><a class="tocitem" href="../helper_functions/">Helper Functions</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API</a></li><li class="is-active"><a href>Estimation Functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Estimation Functions</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/s-baumann/HighFrequencyCovariance.jl/blob/master/docs/src/functions.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Estimation-Functions"><a class="docs-heading-anchor" href="#Estimation-Functions">Estimation Functions</a><a id="Estimation-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Estimation-Functions" title="Permalink"></a></h1><ul><li><a href="#HighFrequencyCovariance.bnhls_covariance"><code>HighFrequencyCovariance.bnhls_covariance</code></a></li><li><a href="#HighFrequencyCovariance.eigenvalue_clean"><code>HighFrequencyCovariance.eigenvalue_clean</code></a></li><li><a href="#HighFrequencyCovariance.estimate_covariance"><code>HighFrequencyCovariance.estimate_covariance</code></a></li><li><a href="#HighFrequencyCovariance.estimate_microstructure_noise"><code>HighFrequencyCovariance.estimate_microstructure_noise</code></a></li><li><a href="#HighFrequencyCovariance.estimate_volatility"><code>HighFrequencyCovariance.estimate_volatility</code></a></li><li><a href="#HighFrequencyCovariance.identity_regularisation"><code>HighFrequencyCovariance.identity_regularisation</code></a></li><li><a href="#HighFrequencyCovariance.nearest_correlation_matrix"><code>HighFrequencyCovariance.nearest_correlation_matrix</code></a></li><li><a href="#HighFrequencyCovariance.nearest_psd_matrix"><code>HighFrequencyCovariance.nearest_psd_matrix</code></a></li><li><a href="#HighFrequencyCovariance.preaveraged_covariance"><code>HighFrequencyCovariance.preaveraged_covariance</code></a></li><li><a href="#HighFrequencyCovariance.regularise"><code>HighFrequencyCovariance.regularise</code></a></li><li><a href="#HighFrequencyCovariance.simple_covariance"><code>HighFrequencyCovariance.simple_covariance</code></a></li><li><a href="#HighFrequencyCovariance.simple_volatility"><code>HighFrequencyCovariance.simple_volatility</code></a></li><li><a href="#HighFrequencyCovariance.spectral_covariance"><code>HighFrequencyCovariance.spectral_covariance</code></a></li><li><a href="#HighFrequencyCovariance.two_scales_covariance"><code>HighFrequencyCovariance.two_scales_covariance</code></a></li><li><a href="#HighFrequencyCovariance.two_scales_volatility"><code>HighFrequencyCovariance.two_scales_volatility</code></a></li></ul><h2 id="Estimating-Volatility"><a class="docs-heading-anchor" href="#Estimating-Volatility">Estimating Volatility</a><a id="Estimating-Volatility-1"></a><a class="docs-heading-anchor-permalink" href="#Estimating-Volatility" title="Permalink"></a></h2><p>The <code>estimate_volatility</code> function is the main volatility estimation function. Either of the two estimation methods can be called by specifying <code>:simple_volatility</code> or <code>:two_scales_volatility</code> as the method argument in the <code>estimate_volatility</code> function. Alternatively the <code>simple_volatility</code> or <code>two_scales_volatility</code> functions can be called directly.</p><p>The <code>simple_volatility</code> returns a  <code>Dict</code> with the estimated volatility for each asset. The <code>two_scales_volatility</code> function on the other hand returns a tuple with a <code>Dict</code> of estimated volatilities in the first position and a <code>Dict</code> of estimated microstructure noise variances in the second. For uniformity of output the <code>estimate_volatility</code> returns a <code>Dict</code> with the estimated volatility for each asset regardless of what method is chosen.</p><p>If a user wants to calculate both volatilities and microstructure noises then they are advised to prefer the <code>two_scales_volatility</code> function over doing both <code>estimate_volatility</code> (with the <code>:two_scale_covariance</code> method argument) and the <code>estimate_microstructure_noise</code> function. While the results are the same doing the two function option means everything is calculated twice.</p><article class="docstring"><header><a class="docstring-binding" id="HighFrequencyCovariance.estimate_volatility" href="#HighFrequencyCovariance.estimate_volatility"><code>HighFrequencyCovariance.estimate_volatility</code></a> — <span class="docstring-category">Function</span></header><section><div><p>This is a convenience wrapper for the two volatility estimation techniques   included in this package. The method can be :simple<em>volatility or   :two</em>scales_volatility in which case the simple or two scales volatilty   methods will be called.</p><pre><code class="language-none">estimate_volatility(ts::SortedDataFrame, assets::Vector{Symbol} = get_assets(ts), method::Symbol = :two_scales_volatility;
                    num_grids::Real = default_num_grids(ts),
                    time_grid::Union{Missing,Dict} = missing , fixed_spacing::Union{Missing,Dict,&lt;:Real} = missing,
                    use_all_obs::Bool = false, rough_guess_number_of_intervals::Integer = 5)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/HighFrequencyCovariance.jl/blob/cd813cb619f6f737e4fcfcc18dc088754d4fcc80/src/50_ConvenienceFunctions.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HighFrequencyCovariance.simple_volatility" href="#HighFrequencyCovariance.simple_volatility"><code>HighFrequencyCovariance.simple_volatility</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Calculates volatility with the simple method.</p><pre><code class="language-none">simple_volatility(ts::SortedDataFrame, assets::Vector{Symbol} = get_assets(ts);
                  time_grid::Union{Missing,Dict} = missing , fixed_spacing::Union{Missing,Dict,&lt;:Real} = missing,
                  use_all_obs::Bool = false, rough_guess_number_of_intervals::Integer = 5)</code></pre><p><strong>Inputs</strong></p><ul><li>ts::SortedDataFrame - The tick data.</li><li>assets::Vector{Symbol} - The assets you want to estimate volatilities for.</li><li>time_grid::Union{Missing,Dict} - The grid with which to calculate returns. If missing one is generated with a fixed spacing (if that is provided) or a default spacing.</li><li>fixed<em>spacing::Union{Missing,Dict,&lt;:Real} - A spacing used to calculate a time grid. Not used if a time</em>grid is input or if use<em>all</em>obs=true.</li><li>use<em>all</em>obs::Bool - Use all observations to estimate volatilities. Not used if a time_grid is provided.</li><li>rough<em>guess</em>number<em>of</em>intervals::Integer - A rough number of intervals to calculate a default spacing. Not used if a time<em>grid or fixed</em>spacing is provided or if use<em>all</em>obs=true.</li><li>T::Real - The duration of the tick data.</li></ul><p><strong>Returns</strong></p><ul><li>A scalar representing the optimal interval spacing.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/HighFrequencyCovariance.jl/blob/cd813cb619f6f737e4fcfcc18dc088754d4fcc80/src/10_volatility_simple.jl#L21-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HighFrequencyCovariance.two_scales_volatility" href="#HighFrequencyCovariance.two_scales_volatility"><code>HighFrequencyCovariance.two_scales_volatility</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Calculates volatility with the two scales method of Zhang, Mykland, Ait-Sahalia 2005. The amount of time for the grid spacing is by default this is a tenth of the total duration by default. If this doesn&#39;t make sense for your use of it then choose a spacing at which you expect the effect of microstructure noise will be small.</p><pre><code class="language-none">two_scales_volatility(vals::Vector, times::Vector, asset::Symbol, num_grids::Real)</code></pre><p><strong>Inputs</strong></p><ul><li>vals::Vector - The prices at each instant in time.</li><li>times::Vector - The times corresponding to each element in vals.</li><li>asset::Symbol - The name of the asset.</li><li>num_grids::Real - Number of grids used in order in two scales estimation.</li></ul><p><strong>Returns</strong></p><ul><li><p>A scalar for the estimated volatility of the asset.</p></li><li><p>A scalar for the estimated microstructure noise variance.</p><p>two<em>scales</em>volatility(ts::SortedDataFrame, assets::Vector{Symbol} = get<em>assets(ts);                         num</em>grids::Real = default<em>num</em>grids(ts))</p></li></ul><p><strong>Inputs</strong></p><ul><li>ts::SortedDataFrame - The tick data.</li><li>assets::Vector{Symbol} - The assets you want to estimate volatilities for.</li><li>num_grids::Real - Number of grids used in order in two scales estimation.</li></ul><p><strong>Returns</strong></p><ul><li>A  Dict with estimated volatilities for each asset.</li><li>A  Dict with estimated microstructure noise variances for each asset.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/HighFrequencyCovariance.jl/blob/cd813cb619f6f737e4fcfcc18dc088754d4fcc80/src/11_volatility_two_scales.jl#L14-L39">source</a></section></article><h2 id="Estimating-Microstructure-Noise"><a class="docs-heading-anchor" href="#Estimating-Microstructure-Noise">Estimating Microstructure Noise</a><a id="Estimating-Microstructure-Noise-1"></a><a class="docs-heading-anchor-permalink" href="#Estimating-Microstructure-Noise" title="Permalink"></a></h2><p>There is one function that returns a <code>Dict</code> of microstructure noise estimates for each asset. These estimates come from the <code>two_scales_volatility</code> method and are identical to what you get if you examine the second element of the tuple that that function outputs.</p><article class="docstring"><header><a class="docstring-binding" id="HighFrequencyCovariance.estimate_microstructure_noise" href="#HighFrequencyCovariance.estimate_microstructure_noise"><code>HighFrequencyCovariance.estimate_microstructure_noise</code></a> — <span class="docstring-category">Function</span></header><section><div><p>This estimates microstructure noise with the two<em>scales</em>volatility method.</p><pre><code class="language-none">estimate_microstructure_noise(ts::SortedDataFrame, assets::Vector{Symbol} = get_assets(ts);
                              num_grids::Real = default_num_grids(ts),
                              time_grid::Union{Missing,Dict} = missing , fixed_spacing::Union{Missing,Dict,&lt;:Real} = missing,
                              use_all_obs::Bool = false, rough_guess_number_of_intervals::Integer = 5)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/HighFrequencyCovariance.jl/blob/cd813cb619f6f737e4fcfcc18dc088754d4fcc80/src/50_ConvenienceFunctions.jl#L32-L40">source</a></section></article><h2 id="Estimating-Covariance-Matrices"><a class="docs-heading-anchor" href="#Estimating-Covariance-Matrices">Estimating Covariance Matrices</a><a id="Estimating-Covariance-Matrices-1"></a><a class="docs-heading-anchor-permalink" href="#Estimating-Covariance-Matrices" title="Permalink"></a></h2><p>The <code>estimate_covariance</code> is the main method for estimating a CovarianceMatrix. Five possible methods can be input to this function (or the functions for each method can alternatively be called directly).</p><p>All covariance estimation functions take in a <code>SortedDataFrame</code> and (optionally) a vector of symbol names representing assets and (optionally) a specified regularisation method. If the vector of symbol names for assets in input then the CovarianceMatrix will only include those input assets and assets will be in the order specified in the vector.</p><p>If the regularisation method is specified then this will be used in regularising the resulting matrix. This can alternatively be <code>missing</code> in which case no regularisation will be done. By default the <code>nearest_psd_matrix</code> will be used for every method except the <code>two\_scales\_covariance</code> method and this regularisation is done on the estimated covariance matrix before its correlation matrix and volatilities are split up and placed in a <code>CovarianceMatrix</code> struct. For the <code>two\_scales\_covariance</code> method the correlation matrix is estimated directly and regularisation is applied to this correlation matrix. Hence the <code>nearest_correlation_matrix</code> is the default.</p><p>Note that some combinations of estimation technique and regularisation technique will not work. For instance <code>nearest_correlation_matrix</code> would not be good to apply in the case of the <code>preaveraged_covariance</code> method as it would attempt to make a covariance matrix into a correlation matrix with a unit diagonal. In addition if the estimated matrix is very non-psd then heavy regularisation might be required. This may have bad results. In these cases it may be useful to turn off regularisation in the estimation function and instead apply regularisation to the <code>CovarianceMatrix</code> struct.</p><article class="docstring"><header><a class="docstring-binding" id="HighFrequencyCovariance.estimate_covariance" href="#HighFrequencyCovariance.estimate_covariance"><code>HighFrequencyCovariance.estimate_covariance</code></a> — <span class="docstring-category">Function</span></header><section><div><p>This is a convenience wrapper for the five covariance estimation techniques included in this package. The method can be :simple<em>covariance, :bnhls</em>covariance, :spectral<em>covariance, :preaveraged</em>covariance or :two<em>scales</em>covariance.</p><pre><code class="language-none">estimate_covariance(ts::SortedDataFrame, assets::Vector{Symbol} = get_assets(ts), method::Symbol = :preaveraged_covariance;
                    regularisation::Union{Missing,Symbol} = :default, regularisation_params::Dict = Dict(),
                    only_regulise_if_not_PSD::Bool = false,
                    time_grid::Union{Missing,Vector} = missing,
                    fixed_spacing::Union{Missing,&lt;:Real} = missing, refresh_times::Bool = false, rough_guess_number_of_intervals::Integer = 5, # General Inputs
                    kernel::HFC_Kernel{&lt;:Real} = parzen, H::Real = kernel.c_star * ( mean(map(a -&gt; length(ts.groupingrows[a]), assets))   )^0.6, m::Integer = 2, # BNHLS parameters
                    numJ::Integer = 100, num_blocks::Integer = 10, block_width::Real = (maximum(ts.df[:,ts.time]) - minimum(ts.df[:,ts.time])) / num_blocks, microstructure_noise_var::Dict{Symbol,&lt;:Real} = two_scales_volatility(ts, assets)[2], # Spectral Covariance parameters
                    theta::Real = 0.15, g::NamedTuple = g, # Preaveraging
                    equalweight::Bool = false, num_grids::Real = default_num_grids(ts))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/HighFrequencyCovariance.jl/blob/cd813cb619f6f737e4fcfcc18dc088754d4fcc80/src/50_ConvenienceFunctions.jl#L50-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HighFrequencyCovariance.simple_covariance" href="#HighFrequencyCovariance.simple_covariance"><code>HighFrequencyCovariance.simple_covariance</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Estimation of the covariance matrix in the standard simple way. https://en.wikipedia.org/wiki/Sample<em>mean</em>and_covariance</p><pre><code class="language-none">simple_covariance(ts::SortedDataFrame, assets::Vector{Symbol} = get_assets(ts); regularisation::Union{Missing,Symbol} = :covariance_default, regularisation_params::Dict = Dict(),
                  only_regulise_if_not_PSD::Bool = false, time_grid::Union{Missing,Vector} = missing,
                  fixed_spacing::Union{Missing,&lt;:Real} = missing, refresh_times::Bool = false, rough_guess_number_of_intervals::Integer = 5)</code></pre><p><strong>Inputs</strong></p><ul><li>ts::SortedDataFrame - The tick data.</li><li>assets::Vector{Symbol} - The assets you want to estimate volatilities for.</li><li>regularisation::Union{Missing,Symbol} - A symbol representing what regularisation technique should be used. If missing no regularisation is performed.</li><li>regularisation_params::Dict - keyword arguments to be consumed in the regularisation algorithm.</li><li>only<em>regulise</em>if<em>not</em>PSD::Bool - Should regularisation only be attempted if the matrix is not psd already.</li><li>time_grid::Union{Missing,Dict} - The grid with which to calculate returns.</li><li>fixed<em>spacing::Union{Missing,Dict,&lt;:Real} - A spacing used to calculate a time grid. Not used if refresh</em>times=true.</li><li>refresh_times::Bool - Should refresh times be used to estimate covariance.</li><li>rough<em>guess</em>number<em>of</em>intervals::Integer - A rough number of intervals to calculate a default spacing. Not used if a time<em>grid or fixed</em>spacing is provided or if refresh_times=true.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>CovarianceMatrix</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/HighFrequencyCovariance.jl/blob/cd813cb619f6f737e4fcfcc18dc088754d4fcc80/src/20_covariance_simple.jl#L44-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HighFrequencyCovariance.bnhls_covariance" href="#HighFrequencyCovariance.bnhls_covariance"><code>HighFrequencyCovariance.bnhls_covariance</code></a> — <span class="docstring-category">Function</span></header><section><div><p>This calculates covariance with the Multivariate realised kernel oof BNHLS(2011).</p><pre><code class="language-none">bnhls_covariance(ts::SortedDataFrame, assets::Vector{Symbol} = get_assets(ts); regularisation::Union{Missing,Symbol} = :covariance_default, regularisation_params::Dict = Dict(),
                 only_regulise_if_not_PSD::Bool = false, kernel::HFC_Kernel{&lt;:Real} = parzen, H::Real = kernel.c_star * ( mean(map(a -&gt; length(ts.groupingrows[a]), assets))   )^0.6,
                 m::Integer = 2)</code></pre><p><strong>Inputs</strong></p><ul><li>ts::SortedDataFrame - The tick data.</li><li>assets::Vector{Symbol} - The assets you want to estimate volatilities for.</li><li>regularisation::Union{Missing,Symbol} - A symbol representing what regularisation technique should be used. If missing no regularisation is performed.</li><li>regularisation_params::Dict - keyword arguments to be consumed in the regularisation algorithm.</li><li>only<em>regulise</em>if<em>not</em>PSD::Bool - Should regularisation only be attempted if the matrix is not psd already.</li><li>kernel::HFC_Kernel{&lt;:Real} - The kernel used. See the paper for details.</li><li>H::Real - The number of lags/leads used in estimation. See the paper for details.</li><li>m::Integer - The number of end returns to average.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>CovarianceMatrix</code>.</li></ul><p><strong>References</strong></p><p>Barndorff-Nielsen, O., Hansen, P.R., Lunde, A., Shephard, N. 2011. - The whole paper but particularly 2.2, 2.3 here. Kernels are in table 1. choices of H are discussed in section 3.4 of the paper.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/HighFrequencyCovariance.jl/blob/cd813cb619f6f737e4fcfcc18dc088754d4fcc80/src/21_covariance_bnhls.jl#L99-L120">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HighFrequencyCovariance.spectral_covariance" href="#HighFrequencyCovariance.spectral_covariance"><code>HighFrequencyCovariance.spectral_covariance</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Estimation of a CovarianceMatrix using the spectral covariance method.</p><pre><code class="language-none">spectral_covariance(ts::SortedDataFrame, assets::Vector{Symbol} = get_assets(ts); regularisation::Union{Missing,Symbol} = :covariance_default, regularisation_params::Dict = Dict(),
                    only_regulise_if_not_PSD::Bool = false, numJ::Integer = 100, num_blocks::Integer = 10, block_width::Real = (maximum(ts.df[:,ts.time]) - minimum(ts.df[:,ts.time])) / num_blocks,
                    microstructure_noise_var::Dict{Symbol,&lt;:Real} = two_scales_volatility(ts, assets)[2])</code></pre><p><strong>Inputs</strong></p><ul><li>ts::SortedDataFrame - The tick data.</li><li>assets::Vector{Symbol} - The assets you want to estimate volatilities for.</li><li>regularisation::Union{Missing,Symbol} - A symbol representing what regularisation technique should be used. If missing no regularisation is performed.</li><li>regularisation_params::Dict - keyword arguments to be consumed in the regularisation algorithm.</li><li>only<em>regulise</em>if<em>not</em>PSD::Bool - Should regularisation only be attempted if the matrix is not psd already.</li><li>numJ::Integer - The number of J values. See the paper for details.</li><li>num_blocks::Integer - The number of blocks to split the time frame into. See the paper for details.</li><li>block_width::Real - The width of each block to split the time frame into.</li><li>microstructure<em>noise</em>var::Dict{Symbol,&lt;:Real} - Estimates of microstructure noise variance for each asset.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>CovarianceMatrix</code>.</li></ul><p><strong>References</strong></p><p>Bibinger M, Hautsch N, Malec P, Reiss M (2014). “Estimating the quadratic covariation matrix from noisy observations: Local method of moments and efficiency.” The Annals of Statistics, 42(4), 1312–1346. doi:10.1214/14-AOS1224.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/HighFrequencyCovariance.jl/blob/cd813cb619f6f737e4fcfcc18dc088754d4fcc80/src/22_covariance_spectral.jl#L88-L111">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HighFrequencyCovariance.preaveraged_covariance" href="#HighFrequencyCovariance.preaveraged_covariance"><code>HighFrequencyCovariance.preaveraged_covariance</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Estimation of the CovarianceMatrix using preaveraging method.</p><pre><code class="language-none">preaveraged_covariance(ts::SortedDataFrame, assets::Vector{Symbol} = get_assets(ts);  regularisation::Union{Missing,Symbol} = :covariance_default, regularisation_params::Dict = Dict(),
                       only_regulise_if_not_PSD::Bool = false, theta::Real = 0.15, g::NamedTuple = g)</code></pre><p><strong>Inputs</strong></p><ul><li>ts::SortedDataFrame - The tick data.</li><li>assets::Vector{Symbol} - The assets you want to estimate volatilities for.</li><li>regularisation::Union{Missing,Symbol} - A symbol representing what regularisation technique should be used. If missing no regularisation is performed.</li><li>regularisation_params::Dict - keyword arguments to be consumed in the regularisation algorithm.</li><li>only<em>regulise</em>if<em>not</em>PSD::Bool - Should regularisation only be attempted if the matrix is not psd already.</li><li>theta::Real - A theta value. See paper for details.</li><li>g::NamedTuple - A tuple containing a preaveraging method (with name &quot;f&quot;) and a ψ value. See paper for details.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>CovarianceMatrix</code>.</li></ul><p><strong>References</strong></p><p>Christensen K, Podolskij M, Vetter M (2013). “On covariation estimation for multivariate continuous Itô semimartingales with noise in non-synchronous observation schemes.” Journal of Multivariate Analysis, 120, 59–84. doi:10.1016/j.jmva.2013.05.002.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/HighFrequencyCovariance.jl/blob/cd813cb619f6f737e4fcfcc18dc088754d4fcc80/src/23_covariance_preaveragingHY.jl#L38-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HighFrequencyCovariance.two_scales_covariance" href="#HighFrequencyCovariance.two_scales_covariance"><code>HighFrequencyCovariance.two_scales_covariance</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Estimation of a CovarianceMatrix using the two scale covariance method.</p><pre><code class="language-none">two_scales_covariance(ts::SortedDataFrame, assets::Vector{Symbol} = get_assets(ts);  regularisation::Union{Missing,Symbol} = :correlation_default, regularisation_params::Dict = Dict(),
                      only_regulise_if_not_PSD::Bool = false, equalweight::Bool = false, num_grids::Real = default_num_grids(ts))</code></pre><p><strong>Inputs</strong></p><ul><li>ts::SortedDataFrame - The tick data.</li><li>assets::Vector{Symbol} - The assets you want to estimate volatilities for.</li><li>regularisation::Union{Missing,Symbol} - A symbol representing what regularisation technique should be used. If missing no regularisation is performed.</li><li>regularisation_params::Dict - keyword arguments to be consumed in the regularisation algorithm.</li><li>only<em>regulise</em>if<em>not</em>PSD::Bool - Should regularisation only be attempted if the matrix is not psd already.</li><li>equalweight::Bool - Should we use equal weight for the two different linear combinations of assets. If false then an optimal weight is calculated (from volatilities).</li><li>num_grids::Real - Number of grids used in order in two scales estimation.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>CovarianceMatrix</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/HighFrequencyCovariance.jl/blob/cd813cb619f6f737e4fcfcc18dc088754d4fcc80/src/24_covariance_two_scales.jl#L20-L36">source</a></section></article><h2 id="Regularisation-of-Covariance-Matrices"><a class="docs-heading-anchor" href="#Regularisation-of-Covariance-Matrices">Regularisation of Covariance Matrices</a><a id="Regularisation-of-Covariance-Matrices-1"></a><a class="docs-heading-anchor-permalink" href="#Regularisation-of-Covariance-Matrices" title="Permalink"></a></h2><p>The main function for regularisation is the <code>regularise</code> function. In addition four methods are implemented for regularising matrices can be used directly or through the <code>regularise</code> function. All of these functions can be applied to either a <code>Hermitian</code> matrix or to a <code>CovarianceMatrix</code> struct.</p><p>If these functions are applied to a <code>Hermitian</code> then regularisation is applied and a regularised <code>Hermitian</code> is returned.</p><p>If these functions are applied to a <code>CovarianceMatrix</code> struct.</p><article class="docstring"><header><a class="docstring-binding" id="HighFrequencyCovariance.regularise" href="#HighFrequencyCovariance.regularise"><code>HighFrequencyCovariance.regularise</code></a> — <span class="docstring-category">Function</span></header><section><div><p>This is a convenience wrapper for the regularisation techniques. The methods can be :identity<em>regularisation, :eigenvalue</em>clean, :nearest<em>correlation</em>matrix or :nearest<em>psd</em>matrix. You can also choose :covariance<em>default (which is :nearest</em>psd<em>matrix) or  :correlation</em>default (which is :nearest<em>correlation</em>matrix).</p><pre><code class="language-none">regularise(mat::Hermitian, ts::SortedDataFrame,  mat_labels::Vector, method::Symbol = :correlation_default;
           spacing::Union{Missing,&lt;:Real} = missing,
           weighting_matrix = Diagonal(eltype(mat).(I(size(mat)[1]))),
           doDykstra = true, stop_at_first_correlation_matrix = true, max_iterates = 1000)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/HighFrequencyCovariance.jl/blob/cd813cb619f6f737e4fcfcc18dc088754d4fcc80/src/50_ConvenienceFunctions.jl#L114-L121">source</a></section><section><div><p>This is a convenience wrapper for the regularisation techniques. The methods can be :identity<em>regularisation, :eigenvalue</em>clean, :nearest<em>correlation</em>matrix or :nearest<em>psd</em>matrix. You can also choose :covariance<em>default (which is :nearest</em>psd<em>matrix) or  :correlation</em>default (which is :nearest<em>correlation</em>matrix).</p><pre><code class="language-none">regularise(covariance_matrix::CovarianceMatrix, ts::SortedDataFrame, method::Symbol = :nearest_correlation_matrix;
           spacing::Union{Missing,&lt;:Real} = missing,
           apply_to_covariance::Bool = true,
           weighting_matrix = Diagonal(eltype(covariance_matrix.correlation).(I(size(covariance_matrix.correlation)[1]))),
           doDykstra = true, stop_at_first_correlation_matrix = true, max_iterates = 1000)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/HighFrequencyCovariance.jl/blob/cd813cb619f6f737e4fcfcc18dc088754d4fcc80/src/50_ConvenienceFunctions.jl#L153-L161">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HighFrequencyCovariance.identity_regularisation" href="#HighFrequencyCovariance.identity_regularisation"><code>HighFrequencyCovariance.identity_regularisation</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Regularisation of the correlation matrix by mixing with the identity matrix as per Ledoit &amp; Wolf 2003.</p><pre><code class="language-none">identity_regularisation(mat::Hermitian, asset_returns::DataFrame)</code></pre><p><strong>Inputs</strong></p><ul><li>mat::Hermitian - A matrix to be regularised.</li><li>asset_returns::DataFrame - A <code>DataFrame</code> with returns for each asset.</li></ul><p><strong>Returns</strong></p><ul><li><p>A <code>Hermitian</code>.</p><p>identity<em>regularisation(mat::Hermitian, asset</em>returns::DataFrame) where R&lt;:Real</p></li></ul><p><strong>Inputs</strong></p><ul><li>mat::Hermitian - A matrix to be regularised.</li><li>ts::SortedDataFrame - Tick data.</li></ul><p><strong>Returns</strong></p><ul><li><p>A <code>Hermitian</code>.</p><p>identity<em>regularisation(covariance</em>matrix::CovarianceMatrix, ts::SortedDataFrame; spacing::Union{Missing,&lt;:Real} = missing, apply<em>to</em>covariance::Bool = true)</p></li></ul><p>This regularises the matrix by doing an elementwise convex linear combination of it with the identity matrix. The weight the identity matrix gets is that specified in Ledoit and Wolf. The inputs are:</p><ul><li>covariance_matrix::CovarianceMatrix or mat::Hermitian - The matrix to be regularised.</li><li>asset_returns::DataFrame - A DataFrame containing returns for each asset. There should be one column for each asset.</li><li>ts::SortedDataFrame - The tick data</li><li>spacing::Union{Missing,&lt;:Real} - What spacing (in time) should returns be calculated from ts. If missing refresh times will be used.</li><li>apply<em>to</em>covariance::Bool - Should regularisation be applied to the correlation or covariance matrix.</li></ul><p>If a <code>Hermitian</code> is input then one will be returned. If a <code>CovarianceMatrix</code> is input then one will be returned.</p><pre><code class="language-none">identity_regularisation(mat::Hermitian, identity_weight::Real)</code></pre><p>This regularises the matrix by doing an elementwise convex linear combination of it  with the identity matrix (where identity_weight is the weight the identity matrix gets).  A <code>Hermitian</code> is returned.</p><p><strong>References</strong></p><p>Ledoit, O. , Wolf, M. 2003. Improved Estimation of the Covariance Matrix of Stock Returns with an application to portfolio selection. Journal of empirical finance. 10. 603-621.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/HighFrequencyCovariance.jl/blob/cd813cb619f6f737e4fcfcc18dc088754d4fcc80/src/30_Regularisation_identity.jl#L14-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HighFrequencyCovariance.eigenvalue_clean" href="#HighFrequencyCovariance.eigenvalue_clean"><code>HighFrequencyCovariance.eigenvalue_clean</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Regularisation of the Hermitian matrix by cleaning out small eigenvalues.</p><pre><code class="language-none">eigenvalue_clean(eigenvalues::Vector{&lt;:Real}, eigenvectors::Matrix{&lt;:Real}, eigenvalue_threshold::Real)
eigenvalue_clean(mat::Hermitian, eigenvalue_threshold::Real)</code></pre><p>This splits a matrix into its eigenvalues and eigenvectors. Then takes the small  eigenvalues (with values below eigenvalue<em>threshold). It sets them to the  greater of their average or eigenvalue</em>threshold/(4*number<em>of</em>small_eigens).  Then the matrix is reconstructed and returned (as a <code>Hermitian</code>)</p><pre><code class="language-none">eigenvalue_clean(mat::Hermitian, ts::SortedDataFrame)
eigenvalue_clean(covariance_matrix::CovarianceMatrix, ts::SortedDataFrame; apply_to_covariance::Bool = true)</code></pre><p>Similarly to the above two methods these functions regularise a matrix by setting small eigenvalues to near zero. The method of Laloux, Cizeau, Bouchaud &amp; Potters 2000 is used to choose a threshold. If a <code>Hermitian</code> is input then a <code>Hermitian</code> will be returned. If a <code>CovarianceMatrix</code> is input then one will be returned. If a <code>CovarianceMatrix</code> is input then users can choose to apply regularisation to the covariance matrix or the correlation matrix. If the latter is done then it is advisable to follow up by regularising the correlation matrix with <code>nearest_correlation_matrix</code> to ensure it has a unit diagonal.</p><p>Note that if the input matrices include any NaN terms then regularisation is not possible. The matrix will be silently returned (as these NaNs will generally be from upstream problems so it is useful to return the matrix rather than throw at this point).As a result outputs should be checked.</p><p><strong>References</strong></p><p>Laloux, L., Cizeau, P., Bouchaud J. , Potters, M. 2000. &quot;Random matrix theory and financial correlations&quot; International Journal of Theoretical Applied FInance, 3, 391-397.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/HighFrequencyCovariance.jl/blob/cd813cb619f6f737e4fcfcc18dc088754d4fcc80/src/32_Regularisation_RMT.jl#L20-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HighFrequencyCovariance.nearest_psd_matrix" href="#HighFrequencyCovariance.nearest_psd_matrix"><code>HighFrequencyCovariance.nearest_psd_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><p>This function maps a Hermitian matrix to the nearest psd matrix. This uses the project<em>to</em>S method in Higham (2001; Theorem 3.2). No special weighting is applied in this case. Advanced users can use the <code>project_to_S</code> directly if they want to use weights in order to decide what the <code>closest</code> pds matrix.</p><pre><code class="language-none">nearest_psd_matrix(mat::Hermitian)
nearest_psd_matrix(covariance_matrix::CovarianceMatrix; apply_to_covariance::Bool = true)
nearest_psd_matrix(covariance_matrix::CovarianceMatrix, ts::SortedDataFrame; apply_to_covariance::Bool = true)</code></pre><p>If a <code>Hermitian</code> is input then a <code>Hermitian</code> will be returned. If a <code>CovarianceMatrix</code> is input then a <code>CovarianceMatrix</code> will be returned.</p><p><strong>References</strong></p><p>Higham NJ (2002). &quot;Computing the nearest correlation matrix - a problem from finance.&quot; IMA Journal of Numerical Analysis, 22, 329–343. doi:10.1002/nla.258.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/HighFrequencyCovariance.jl/blob/cd813cb619f6f737e4fcfcc18dc088754d4fcc80/src/31_Regularisation_NearestCorrelationMatrix.jl#L142-L157">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HighFrequencyCovariance.nearest_correlation_matrix" href="#HighFrequencyCovariance.nearest_correlation_matrix"><code>HighFrequencyCovariance.nearest_correlation_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Maps a matrix to the nearest valid correlation matrix (pdf matrix with unit diagonal and all other entries below 1 in absolute value).</p><pre><code class="language-none">nearest_correlation_matrix(covariance_matrix::CovarianceMatrix, ts::SortedDataFrame; weighting_matrix::Union{Diagonal,Hermitian} = Diagonal(eltype(covariance_matrix.correlation).(I(size(covariance_matrix.correlation)[1]))),
                             doDykstra::Bool = true, stop_at_first_correlation_matrix::Bool = true, max_iterates::Integer = 1000)
nearest_correlation_matrix(covariance_matrix::CovarianceMatrix; weighting_matrix::Union{Diagonal,Hermitian} = Diagonal(eltype(covariance_matrix.correlation).(I(size(covariance_matrix.correlation)[1]))),
                             doDykstra::Bool = true, stop_at_first_correlation_matrix::Bool = true, max_iterates::Integer = 1000)
nearest_correlation_matrix(mat::Hermitian, ts::SortedDataFrame, mat_labels = missing; weighting_matrix = Diagonal(eltype(mat).(I(size(mat)[1]))),
                             doDykstra::Bool = true, stop_at_first_correlation_matrix::Bool = true, max_iterates::Integer = 1000)
nearest_correlation_matrix(mat::Hermitian, mat_labels::Vector = missing; weighting_matrix = Diagonal(eltype(mat).(I(size(mat)[1]))),
                             doDykstra::Bool = true, stop_at_first_correlation_matrix::Bool = true, max_iterates::Integer = 1000)</code></pre><p>These functions calls the <code>iterate_higham</code> function to move a matrix towards it nearest correlation matrix until it hits a fixed point.</p><ul><li>covariance_matrix::CovarianceMatrix or mat::Hermitian - The matrix to be regularised.</li><li>ts::SortedDataFrame - The tick data</li><li>weighting_matrix::Union{Diagonal,Hermitian} - What weighting matrix should be used (in determining what is the nearest correlation matrix).</li><li>doDykstra::Bool Should a Dykstra correction be done.</li><li>stop<em>at</em>first<em>correlation</em>matrix::Bool  Should the iteration stop at the first valid correlation matrix or continue until all iterates have been performed.</li><li>max<em>iterates::Integer What is the maximum number of iterates to do. If stop</em>at<em>first</em>correlation<em>matrix = false then max</em>iterates is the number of iterates that we will do.</li></ul><p>If a <code>Hermitian</code> is input then one will be returned. If a <code>CovarianceMatrix</code> is input then one will be returned.</p><pre><code class="language-none"> nearest_correlation_matrix(mat::Union{Diagonal,Hermitian}, W::Union{Diagonal,Hermitian} = Diagonal(Float64.(I(size(mat)[1])));
                             doDykstra::Bool = true, stop_at_first_correlation_matrix::Bool = true, max_iterates::Integer = 1000)</code></pre><p>This also iterates a matrix towards convergence but returns a tuple with the updated  Hermitian/Diagonal matrix in the first slot, the number of iterates in the second  and a Symbol representing a convergence status in the third. The arguments are as above.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/HighFrequencyCovariance.jl/blob/cd813cb619f6f737e4fcfcc18dc088754d4fcc80/src/31_Regularisation_NearestCorrelationMatrix.jl#L69-L96">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../types/">« Types</a><a class="docs-footer-nextpage" href="../helper_functions/">Helper Functions »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 2 August 2021 23:31">Monday 2 August 2021</span>. Using Julia version 1.5.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

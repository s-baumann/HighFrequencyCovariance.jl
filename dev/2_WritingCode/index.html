<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Using HighFrequencyCovariance · HighFrequencyCovariance</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">HighFrequencyCovariance</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">HighFrequencyCovariance</a></li><li><a class="tocitem" href="../1_algorithms/">Algorithms</a></li><li class="is-active"><a class="tocitem" href>Using HighFrequencyCovariance</a><ul class="internal"><li><a class="tocitem" href="#Main-Structs"><span>Main Structs</span></a></li><li><a class="tocitem" href="#Loading-in-data"><span>Loading in data</span></a></li><li><a class="tocitem" href="#Estimating-a-covariance-matrix"><span>Estimating a covariance matrix</span></a></li></ul></li><li><a class="tocitem" href="../9_references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Using HighFrequencyCovariance</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Using HighFrequencyCovariance</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/s-baumann/HighFrequencyCovariance.jl/blob/master/docs/src/2_WritingCode.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Using-HighFrequencyCovariance"><a class="docs-heading-anchor" href="#Using-HighFrequencyCovariance">Using HighFrequencyCovariance</a><a id="Using-HighFrequencyCovariance-1"></a><a class="docs-heading-anchor-permalink" href="#Using-HighFrequencyCovariance" title="Permalink"></a></h1><h2 id="Main-Structs"><a class="docs-heading-anchor" href="#Main-Structs">Main Structs</a><a id="Main-Structs-1"></a><a class="docs-heading-anchor-permalink" href="#Main-Structs" title="Permalink"></a></h2><p>HighFrequencyCovariance has two main structs. The first is CovarianceMatrix which is:</p><pre><code class="language-none">mutable struct CovarianceMatrix{R&lt;:Real}
    correlation::Hermitian{R}
    volatility::Array{R,1}
    labels::Array{Symbol,1}
end</code></pre><p>A CovarianceMatrix struct thus contains three elements. A correlation matrix, a volatility vector and a vector that labels each row/column of the correlation matrix and each row of the volatility vector. Note that an actual covariance matrix is not stored but can be calculated over some interval with the function:</p><pre><code class="language-none">covariance(cm::CovarianceMatrix, duration::Real)</code></pre><p>The second main struct is a SortedDataFrame which is:</p><pre><code class="language-none">struct SortedDataFrame
    df::DataFrame
    time::Symbol
    grouping::Symbol
    value::Symbol
    groupingrows::Dict{Symbol,Array{Int64,1}}
end</code></pre><p>This presorts a dataframe by time and adds in an index (groupingrows) for each asset. Together these measures allow the covariance estimation functions to run faster as they can efficiently access the data. The other struct elements are the labels of the columns of interest in the dataframe.</p><h2 id="Loading-in-data"><a class="docs-heading-anchor" href="#Loading-in-data">Loading in data</a><a id="Loading-in-data-1"></a><a class="docs-heading-anchor-permalink" href="#Loading-in-data" title="Permalink"></a></h2><p>We first load our data into a dataframe. As an example we have a dataframe of price updates (like that in df below). Then we can put our data into a SortedDataFrame by putting the dataframe and the names of the time, label and value columns into the constructor:</p><pre><code class="language-none">using HighFrequencyCovariance
using DataFrames
df = DataFrame(:stock =&gt; [:A,:B,:A,:A,:A,:B,:A,:B,:B], :time =&gt; [1,2,3,4,5,5,6,7,8],
               :logprice =&gt; [1.01,2.0,1.011,1.02,1.011,2.2,1.0001,2.2,2.3])
ts = SortedDataFrame(df, :time, :stock, :logprice)</code></pre><p>In a real setting this is how we would turn our dataframe of data into a SortedDataFrame.</p><p>For the suceeding sections it is useful to get more realistic time series data. So we will generate some Monte Carlo data here using the generate_random_path function which generates a random correlation matrix, volatilities, price update times and microstructure noises and generates a SortedDataFrame from a random time series consistent with these.</p><pre><code class="language-none">using HighFrequencyCovariance
dims = 4
ticks = 4000
ts, true_covar, true_micro_noise, true_update_rates = generate_random_path(dims, ticks)</code></pre><h2 id="Estimating-a-covariance-matrix"><a class="docs-heading-anchor" href="#Estimating-a-covariance-matrix">Estimating a covariance matrix</a><a id="Estimating-a-covariance-matrix-1"></a><a class="docs-heading-anchor-permalink" href="#Estimating-a-covariance-matrix" title="Permalink"></a></h2><p>As this is a Monte Carlo we already have the true CovarianceMatrix in the true_covar variable. As we don&#39;t have this in applied settings we will disregard this for now and try to estimate it using our data from ts_data:</p><pre><code class="language-none">assets              = get_assets(ts_data)
simple_estimate     = simple_covariance(ts_data, assets)
bnhls_estimate      = bnhls_covariance(ts_data, assets)
spectral_estimate   = spectral_covariance(ts_data, assets)
preav_estimate      = preaveraged_covariance(ts_data, assets)
two_scales_estimate = two_scales_covariance(ts_data, assets)</code></pre><p>Now we may be particularly interested in one of the estimates, for instance the bnhls estimate. We can first see if the correlation matrix is valid:</p><pre><code class="language-none">valid_correlation_matrix(bnhls_estimate)
# true</code></pre><p>and fortunately it is. We could also examine the others similarly and see that they all deliver valid correlation matrices. One thing we might try then is to average over all of the more advanced methods and use the result as our correlation matrix estimate. This is easy to achieve by using the <strong>combine_covariance_matrices</strong> function.</p><pre><code class="language-none">matrices = [spectral_estimate, preav_estimate, two_scales_estimate, bnhls_estimate]
combined_estimate = combine_covariance_matrices(matrices)</code></pre><p>Now we can compare how close each of the estimates is to the true correlation matrix. We can do this by examining the mean absolute difference between estimated correlations.</p><pre><code class="language-none">calculate_mean_abs_distance(true_covar, combined_estimate)
# (Correlation_error = 0.16456385637458595, Volatility_error = 0.004544707431296664)
calculate_mean_abs_distance(true_covar, simple_estimate)
# (Correlation_error = 0.448889645637147, Volatility_error = 0.011006475712027963)
calculate_mean_abs_distance(true_covar, bnhls_estimate)
# (Correlation_error = 0.23409341003189574, Volatility_error = 0.001093802689437351)
calculate_mean_abs_distance(true_covar, spectral_estimate)
# (Correlation_error = 0.22234619862055216, Volatility_error = 0.00385672089771947)
calculate_mean_abs_distance(true_covar, preav_estimate)
# (Correlation_error = 0.14664816908395706, Volatility_error = 0.0017134509530432648)
calculate_mean_abs_distance(true_covar, two_scales_estimate)
# (Correlation_error = 0.3577017001321916, Volatility_error = 0.0017134509530432648)</code></pre><p>We can see that in this particular case the correlation matrix calculated with preaveraging performed the best.</p><p>Now examining the data we can see that we have some assets that trade more frequently than the others.</p><pre><code class="language-none">ticks_per_asset(ts_data)
# Dict{Symbol,Int64} with 4 entries:
#  :asset_4 =&gt; 6848
#  :asset_3 =&gt; 6588
#  :asset_2 =&gt; 2630
#  :asset_1 =&gt; 3934</code></pre><p>While we have 6848 price updates for asset_4 we only have 2630 for asset_2. Potentially we could improve the bnhls estimate if we use a blocking and regularisation technique (Hautsch, Kyj and Oomen  2012).</p><p>We can start this by first making a dataframe detailing what assets should be in what block. We will generate a new block if the minimum number of ticks of a new block has 20% more ticks than the minimum of the previous:</p><pre><code class="language-none">new_block_threshold = 1.2
blocking_frame = put_assets_into_blocks_by_trading_frequency(
                        ts_data, new_block_threshold, bnhls_covariance)</code></pre><p>This blocking_frame is a regular dataframe with six columns where each row represents a different estimation. The order of the rows is the order of estimations (so the results of later estimations may overwrite earlier ones). The first column is named :assets and has the type Set{Symbol} which represents the assets in each estimation. The second column contains the function that will be used in the estimation of that block. The third column has the name :optional_parameters and is of type NamedTuple that can provide optional parameters to the covariance function in the second column. Every covariance estimation has a function signature with two common arguments before the semicolon (For a SortedDataFrame and a vector of symbols representing what assets to use). There can also be a number of named optional arguments which can be sourced from a NamedTuple. The <strong>blockwise_estimation</strong> function then estimates a block with the line</p><pre><code class="language-none">blocking_frame[i,:f](ts_data, collect(blocking_frame[i,:assets]);
                     blocking_frame[i,:optional_parameters]... )</code></pre><p>Thus a user can insert a named tuple containing whatever optional parameters are used by the function.</p><p>The fourth, fifth and sixth columns contains the number of assets in the block, the mean number of ticks in the block and the mean time per tick. These do not do anything in the subsequent <strong>blockwise_estimation</strong> function but can be used to alter the dataframe. Now in the current case we may decide to estimate the block containing all assets using the <strong>spectral_covariance</strong> method.</p><pre><code class="language-none">one_asset_row = findall(blocking_frame[:,:number_of_assets] .== 4)
blocking_frame[one_asset_row, :f] = spectral_covariance</code></pre><p>We can now estimate the blockwise estimated CovarianceMatrix as:</p><pre><code class="language-none">block_estimate = blockwise_estimation(ts_data, blocking_frame)</code></pre><p>After a blockwise estimation the result may often not be PSD. So we could regularise at this point:</p><pre><code class="language-none">reg_block_estimate = nearest_correlation_matrix(block_estimate , ts_data)</code></pre><p>Finally we might seek to use one of our estimated <strong>CovarianceMatrix</strong>s to calculate an actual covariance matrix over some interval. This can be done with the code:</p><pre><code class="language-none">covariance_interval = 1000
covar = covariance(combined_estimate, covariance_interval)</code></pre><p>Note that the time units of the covariance_interval here should be the same units as the CovarianceMatrix struct&#39;s volatility which are the same units as the time dimension in the SortedDataFrame that is used to estimate the CovarianceMatrix.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../1_algorithms/">« Algorithms</a><a class="docs-footer-nextpage" href="../9_references/">References »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 11 January 2021 23:00">Monday 11 January 2021</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

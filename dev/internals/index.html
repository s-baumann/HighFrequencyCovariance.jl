<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Internal Functions · HighFrequencyCovariance.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">HighFrequencyCovariance.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><span class="tocitem">First Steps with HighFrequencyCovariance.jl</span><ul><li><a class="tocitem" href="../1_algorithms/">Algorithms</a></li><li><a class="tocitem" href="../2_data_structures/">Data Structures</a></li><li><a class="tocitem" href="../3_WritingCode/">Writing Code</a></li><li><a class="tocitem" href="../9_references/">References</a></li></ul></li><li><span class="tocitem">Performance Comparison</span><ul><li><a class="tocitem" href="../4_performance_comparison/">Performance Comparison</a></li></ul></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="../types/">Types</a></li><li><a class="tocitem" href="../functions/">Estimation Functions</a></li><li><a class="tocitem" href="../helper_functions/">Helper Functions</a></li><li class="is-active"><a class="tocitem" href>Internal Functions</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API</a></li><li class="is-active"><a href>Internal Functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Internal Functions</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/s-baumann/HighFrequencyCovariance.jl/blob/main/docs/src/internals.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Internal-Functions"><a class="docs-heading-anchor" href="#Internal-Functions">Internal Functions</a><a id="Internal-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Internal-Functions" title="Permalink"></a></h1><ul><li><a href="#HighFrequencyCovariance.bnhls_2008"><code>HighFrequencyCovariance.bnhls_2008</code></a></li><li><a href="#HighFrequencyCovariance.fejer"><code>HighFrequencyCovariance.fejer</code></a></li><li><a href="#HighFrequencyCovariance.g"><code>HighFrequencyCovariance.g</code></a></li><li><a href="#HighFrequencyCovariance.parzen"><code>HighFrequencyCovariance.parzen</code></a></li><li><a href="#HighFrequencyCovariance.quadratic_spectral"><code>HighFrequencyCovariance.quadratic_spectral</code></a></li><li><a href="#HighFrequencyCovariance.tukey_hanning"><code>HighFrequencyCovariance.tukey_hanning</code></a></li><li><a href="#HighFrequencyCovariance.HFC_Kernel"><code>HighFrequencyCovariance.HFC_Kernel</code></a></li><li><a href="#HighFrequencyCovariance.calculate_mean_abs_distance"><code>HighFrequencyCovariance.calculate_mean_abs_distance</code></a></li><li><a href="#HighFrequencyCovariance.default_num_grids"><code>HighFrequencyCovariance.default_num_grids</code></a></li><li><a href="#HighFrequencyCovariance.get_all_refresh_times"><code>HighFrequencyCovariance.get_all_refresh_times</code></a></li><li><a href="#HighFrequencyCovariance.get_refresh_times_and_prices"><code>HighFrequencyCovariance.get_refresh_times_and_prices</code></a></li><li><a href="#HighFrequencyCovariance.is_missing_nan_inf"><code>HighFrequencyCovariance.is_missing_nan_inf</code></a></li><li><a href="#HighFrequencyCovariance.iterate_higham"><code>HighFrequencyCovariance.iterate_higham</code></a></li><li><a href="#HighFrequencyCovariance.latest_value"><code>HighFrequencyCovariance.latest_value</code></a></li><li><a href="#HighFrequencyCovariance.next_tick"><code>HighFrequencyCovariance.next_tick</code></a></li><li><a href="#HighFrequencyCovariance.project_to_S"><code>HighFrequencyCovariance.project_to_S</code></a></li><li><a href="#HighFrequencyCovariance.project_to_U"><code>HighFrequencyCovariance.project_to_U</code></a></li><li><a href="#HighFrequencyCovariance.random_value_in_interval"><code>HighFrequencyCovariance.random_value_in_interval</code></a></li><li><a href="#HighFrequencyCovariance.safe_multiply_period"><code>HighFrequencyCovariance.safe_multiply_period</code></a></li><li><a href="#HighFrequencyCovariance.simple_volatility_given_returns"><code>HighFrequencyCovariance.simple_volatility_given_returns</code></a></li><li><a href="#HighFrequencyCovariance.squared_frobenius"><code>HighFrequencyCovariance.squared_frobenius</code></a></li><li><a href="#HighFrequencyCovariance.squared_frobenius_distance"><code>HighFrequencyCovariance.squared_frobenius_distance</code></a></li><li><a href="#HighFrequencyCovariance.time_between_refreshes"><code>HighFrequencyCovariance.time_between_refreshes</code></a></li><li><a href="#HighFrequencyCovariance.time_period_ratio"><code>HighFrequencyCovariance.time_period_ratio</code></a></li><li><a href="#HighFrequencyCovariance.weighted_mean"><code>HighFrequencyCovariance.weighted_mean</code></a></li></ul><h3 id="Metrics-for-distances-between-CovarianceMatrix-structs"><a class="docs-heading-anchor" href="#Metrics-for-distances-between-CovarianceMatrix-structs">Metrics for distances between CovarianceMatrix structs</a><a id="Metrics-for-distances-between-CovarianceMatrix-structs-1"></a><a class="docs-heading-anchor-permalink" href="#Metrics-for-distances-between-CovarianceMatrix-structs" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="HighFrequencyCovariance.calculate_mean_abs_distance" href="#HighFrequencyCovariance.calculate_mean_abs_distance"><code>HighFrequencyCovariance.calculate_mean_abs_distance</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">calculate_mean_abs_distance(
    cov1::CovarianceMatrix,
    cov2::CovarianceMatrix,
    decimal_places::Integer = 8;
    return_nans_if_symbols_dont_match::Bool = true,
)</code></pre><p>Calculates the mean absolute distance (elementwise in L1 norm) between two <code>CovarianceMatrix</code>s. Undefined if any labels differ between the two <code>CovarianceMatrix</code>s.</p><p><strong>Inputs</strong></p><ul><li><code>cov1</code> - The first <code>CovarianceMatrix</code></li><li><code>cov2</code> - The second <code>CovarianceMatrix</code></li><li><code>decimal_places</code> - How many decimal places to show the result to.</li><li><code>return_nans_if_symbols_dont_match</code> - If the symbols don&#39;t match should it be an error. Or if false we only compare common symbols in both <code>CovarianceMatrix</code>s</li></ul><p><strong>Returns</strong></p><ul><li><p>An <code>Tuple</code> with the distance for correlations in first entry and distance for volatilities in the second.</p><p>calculate<em>mean</em>abs_distance(d1::Dict{Symbol,&lt;:Real}, d2::Dict{Symbol,&lt;:Real})</p></li></ul><p>Calculates the mean absolute distance (elementwise in L1 norm) between two <code>CovarianceMatrix</code>s.</p><p><strong>Inputs</strong></p><ul><li><code>d1</code> - The first <code>Dict</code></li><li><code>d2</code> - The second <code>Dict</code></li></ul><p><strong>Returns</strong></p><ul><li>A scalar with the mean distance between matching elements.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/HighFrequencyCovariance.jl/blob/4449051aff628d2a7e625bec54200a4264187610/src/00_CovarianceMatrix.jl#L116-L142">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HighFrequencyCovariance.squared_frobenius" href="#HighFrequencyCovariance.squared_frobenius"><code>HighFrequencyCovariance.squared_frobenius</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">squared_frobenius(x1::AbstractMatrix)</code></pre><p>Returns the squared frobenius norm of a matrix. This is a real.</p><p><strong>Inputs</strong></p><ul><li><code>x1</code> The matrix that you want the squared frobenius norm for.</li></ul><p><strong>Returns</strong></p><ul><li>A Scalar.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/HighFrequencyCovariance.jl/blob/4449051aff628d2a7e625bec54200a4264187610/src/01_helpers.jl#L343-L351">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HighFrequencyCovariance.squared_frobenius_distance" href="#HighFrequencyCovariance.squared_frobenius_distance"><code>HighFrequencyCovariance.squared_frobenius_distance</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">squared_frobenius_distance(x1::AbstractMatrix, x2::AbstractMatrix = x1)</code></pre><p>Returns the squared frobenius distance between two matrices. This is a real.</p><p><strong>Inputs</strong></p><ul><li><code>x1</code> The first matrix.</li><li><code>x2</code> The second matrix.</li></ul><p><strong>Returns</strong></p><ul><li>A Scalar.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/HighFrequencyCovariance.jl/blob/4449051aff628d2a7e625bec54200a4264187610/src/01_helpers.jl#L330-L339">source</a></section></article><h3 id="Used-in-volatility-estimation-techniques"><a class="docs-heading-anchor" href="#Used-in-volatility-estimation-techniques">Used in volatility estimation techniques</a><a id="Used-in-volatility-estimation-techniques-1"></a><a class="docs-heading-anchor-permalink" href="#Used-in-volatility-estimation-techniques" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="HighFrequencyCovariance.default_num_grids" href="#HighFrequencyCovariance.default_num_grids"><code>HighFrequencyCovariance.default_num_grids</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">default_num_grids(ts::SortedDataFrame)</code></pre><p>This gives a default number of intervals to divide a series of ticks over for the purposes of estimating returns and volatility.</p><p><strong>Inputs</strong></p><ul><li><code>ts</code> - The tick data.</li></ul><p><strong>Returns</strong></p><ul><li>An integer for the number of intervals.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/HighFrequencyCovariance.jl/blob/4449051aff628d2a7e625bec54200a4264187610/src/11_volatility_two_scales.jl#L18-L26">source</a></section></article><h3 id="Used-in-covariance-estimation-techniques"><a class="docs-heading-anchor" href="#Used-in-covariance-estimation-techniques">Used in covariance estimation techniques</a><a id="Used-in-covariance-estimation-techniques-1"></a><a class="docs-heading-anchor-permalink" href="#Used-in-covariance-estimation-techniques" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="HighFrequencyCovariance.get_all_refresh_times" href="#HighFrequencyCovariance.get_all_refresh_times"><code>HighFrequencyCovariance.get_all_refresh_times</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_all_refresh_times(
    ts::SortedDataFrame,
    assets::Vector{Symbol} = get_assets(ts);
    start_time::R = minimum(ts.df[:, ts.time]),
) where R&lt;:Real</code></pre><p>Get a vector of all refresh times when all assets have an updated price. So if there are assets A and B that trade at times (1,5,6,7,10) and (2,5,7,9) then the refresh times are (2,5,7,10) as at these four times there are updated prices for all assets that have happened since the previous refresh time.</p><p><strong>Inputs</strong></p><ul><li><code>ts</code> - The tick data.</li><li><code>assets</code> - The assets of interest.</li><li><code>start_time</code> - From what time should we start looking for updated prices.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>Vector</code> of refresh times.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/HighFrequencyCovariance.jl/blob/4449051aff628d2a7e625bec54200a4264187610/src/02_subsample_ticks.jl#L128-L145">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HighFrequencyCovariance.latest_value" href="#HighFrequencyCovariance.latest_value"><code>HighFrequencyCovariance.latest_value</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">latest_value(
    ts::SortedDataFrame,
    at_times::Vector{&lt;:Real};
    assets::Vector{Symbol} = get_assets(ts),
)</code></pre><p>Get the latest price at a each input time.</p><p><strong>Inputs</strong></p><ul><li><code>ts</code> - The tick data.</li><li><code>at_times</code> - The times you want the latest prices for.</li><li><code>assets</code> - The assets you want latest prices for.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>DataFrame</code>. Rows are for each time specified in at_times. Columns are for each asset.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/HighFrequencyCovariance.jl/blob/4449051aff628d2a7e625bec54200a4264187610/src/02_subsample_ticks.jl#L2-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HighFrequencyCovariance.time_between_refreshes" href="#HighFrequencyCovariance.time_between_refreshes"><code>HighFrequencyCovariance.time_between_refreshes</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">time_between_refreshes(
   ts::SortedDataFrame;
   assets::Vector{Symbol} = get_assets(ts),
)</code></pre><p>Get a <code>DataFrame</code> showing how many time is between each refresh and how many ticks in total.</p><p><strong>Inputs</strong></p><ul><li><code>ts</code> - Tick data.</li><li><code>assets</code> - A <code>Vector</code> of labels.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>DataFrame</code> summarising the average number of time between ticks for each asset.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/HighFrequencyCovariance.jl/blob/4449051aff628d2a7e625bec54200a4264187610/src/01_helpers.jl#L359-L371">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HighFrequencyCovariance.random_value_in_interval" href="#HighFrequencyCovariance.random_value_in_interval"><code>HighFrequencyCovariance.random_value_in_interval</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">random_value_in_interval(
   ts::SortedDataFrame,
   at_times::Vector{&lt;:Real};
   assets::Vector{Symbol} = get_assets(ts),
   twister_arb_value_in_interval::MersenneTwister = MersenneTwister(2604),
)</code></pre><p>Get a random value in an interval. So if you input times 1,7,8 then for the second entry it will pick a random update (if any exist) between times 1 and 7.</p><p><strong>Inputs</strong></p><ul><li><code>ts</code> - The tick data.</li><li><code>at_times</code> - The times that seperate the intervals of interest.</li><li><code>assets</code> - The assets of interest.</li><li><code>twister_arb_value_in_interval</code> - The RNG used in selecting the random interval.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>DataFrame</code> with prices for each asset from random ticks in each interval.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/HighFrequencyCovariance.jl/blob/4449051aff628d2a7e625bec54200a4264187610/src/02_subsample_ticks.jl#L61-L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HighFrequencyCovariance.g" href="#HighFrequencyCovariance.g"><code>HighFrequencyCovariance.g</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">const g = (f = x-&gt; min(x, 1-x), psi = 0.25)</code></pre><p>This named tuple gives the preaveraging kernel function and integral over the unit interval    that was used in the paper. It is used by default in the preaveraged_covariance method    but can be overwritten with alternative kernels.</p><p><strong>References</strong></p><p>Christensen K, Podolskij M, Vetter M (2013). “On covariation estimation for multivariate continuous Itô semimartingales with noise in non-synchronous observation schemes.” Journal of Multivariate Analysis, 120, 59–84. doi:10.1016/j.jmva.2013.05.002.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/HighFrequencyCovariance.jl/blob/4449051aff628d2a7e625bec54200a4264187610/src/23_covariance_preaveragingHY.jl#L69-L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HighFrequencyCovariance.get_refresh_times_and_prices" href="#HighFrequencyCovariance.get_refresh_times_and_prices"><code>HighFrequencyCovariance.get_refresh_times_and_prices</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_refresh_times_and_prices(ts::SortedDataFrame, asset1::Symbol, asset2::Symbol)</code></pre><p>This returns a vector of prices and refresh times given two input symbols</p><p><strong>Inputs</strong></p><ul><li><code>ts</code> - The tick data.</li><li><code>asset1</code> - The first asset&#39;s name.</li><li><code>asset2</code> - The second asset&#39;s name.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>Vector</code> of prices</li><li>A <code>Vector</code> of times corresponding to these prices.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/HighFrequencyCovariance.jl/blob/4449051aff628d2a7e625bec54200a4264187610/src/24_covariance_two_scales.jl#L47-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HighFrequencyCovariance.time_period_ratio" href="#HighFrequencyCovariance.time_period_ratio"><code>HighFrequencyCovariance.time_period_ratio</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">time_period_ratio(neww::Dates.Period, oldd::Dates.Period)</code></pre><p>This calculates the ratio of the interval length between two periods. So if neww is twice as long a period as oldd it will return a 2.0.</p><p><strong>Inputs</strong></p><ul><li><code>neww</code> - A time period</li><li><code>oldd</code> - A time period</li></ul><p><strong>Returns</strong></p><ul><li>A real number.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/HighFrequencyCovariance.jl/blob/4449051aff628d2a7e625bec54200a4264187610/src/00_SortedDataFrame.jl#L100-L112">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HighFrequencyCovariance.safe_multiply_period" href="#HighFrequencyCovariance.safe_multiply_period"><code>HighFrequencyCovariance.safe_multiply_period</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">safe_multiply_period(scalar::Real, period::Dates.Period)</code></pre><p>This multiplies a time period by a scalar. So if period is Dates.Hour(1) and we multiply by 2 we will get two hours (although that will be expressed in Nanosecond units).</p><p><strong>Inputs</strong></p><ul><li><code>scalar</code> - A real number</li><li><code>period</code> - A time period</li></ul><p><strong>Returns</strong></p><ul><li>A time period expressed in Nanosecond units.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/HighFrequencyCovariance.jl/blob/4449051aff628d2a7e625bec54200a4264187610/src/00_SortedDataFrame.jl#L117-L129">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HighFrequencyCovariance.weighted_mean" href="#HighFrequencyCovariance.weighted_mean"><code>HighFrequencyCovariance.weighted_mean</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">weighted_mean(x::Vector, w::Vector)</code></pre><p>This calculates a weighted mean given vectors for values and for weights.     If the sum of the absolute values of the weights is close to zero a simple mean     of x is returned instead.</p><p><strong>Inputs</strong></p><ul><li><code>x</code> - A <code>Vector</code> of the values you want to average.</li><li><code>w</code> - A <code>Vector</code> of the weights you want to use.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>Real</code> number for the weighted mean.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/HighFrequencyCovariance.jl/blob/4449051aff628d2a7e625bec54200a4264187610/src/01_helpers.jl#L191-L202">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HighFrequencyCovariance.is_missing_nan_inf" href="#HighFrequencyCovariance.is_missing_nan_inf"><code>HighFrequencyCovariance.is_missing_nan_inf</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">is_missing_nan_inf(x) = (ismissing(x) || isnan(x)) || isinf(x)</code></pre><p>This tests if a value is missing, nan or inf and returns true if one of these things is true.</p><p><strong>Inputs</strong></p><ul><li><code>x</code> - The object to test for missing, inf, nan.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>Bool</code> for whether or not one of these conditions is true.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/HighFrequencyCovariance.jl/blob/4449051aff628d2a7e625bec54200a4264187610/src/01_helpers.jl#L220-L228">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HighFrequencyCovariance.next_tick" href="#HighFrequencyCovariance.next_tick"><code>HighFrequencyCovariance.next_tick</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">next_tick(ts::SortedDataFrame, from_index::I;
                   assets::Vector{Symbol} = get_assets(ts)) where I&lt;:Integer</code></pre><p>This gets the next tick by which every asset has a refreshed price after a certain row index.</p><p><strong>Inputs</strong></p><ul><li><code>ts</code> - The tick data.</li><li><code>from_index</code> - The index in your ts.df to start looking from.</li><li><code>assets</code> - The vector of assets that you want to get a refresh time by which each has a refreshed price.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>Real</code> or <code>Missing</code> for the refresh time. If it is a real it is the time. If one asset did not update in your data then a missing is returned.</li><li>An <code>Integer</code> or <code>Missing</code> for the refresh tick. for what index in your data the refresh happened by. If one asset did not refresh this will be a missing.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/HighFrequencyCovariance.jl/blob/4449051aff628d2a7e625bec54200a4264187610/src/02_subsample_ticks.jl#L101-L113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HighFrequencyCovariance.simple_volatility_given_returns" href="#HighFrequencyCovariance.simple_volatility_given_returns"><code>HighFrequencyCovariance.simple_volatility_given_returns</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">simple_volatility_given_returns(returns::Vector{R}) where R&lt;:Real</code></pre><p>Calculates volatility using a vector of returns using the square root of squared returns.</p><p><strong>Inputs</strong></p><ul><li><code>returns</code> - A vector of returns</li></ul><p><strong>Returns</strong></p><ul><li>A <code>Real</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/HighFrequencyCovariance.jl/blob/4449051aff628d2a7e625bec54200a4264187610/src/10_volatility_simple.jl#L2-L9">source</a></section></article><h3 id="Kernels-used-in-the-BNHLS-method"><a class="docs-heading-anchor" href="#Kernels-used-in-the-BNHLS-method">Kernels used in the BNHLS method</a><a id="Kernels-used-in-the-BNHLS-method-1"></a><a class="docs-heading-anchor-permalink" href="#Kernels-used-in-the-BNHLS-method" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="HighFrequencyCovariance.HFC_Kernel" href="#HighFrequencyCovariance.HFC_Kernel"><code>HighFrequencyCovariance.HFC_Kernel</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A kernel used in the bnhls covariance method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/HighFrequencyCovariance.jl/blob/4449051aff628d2a7e625bec54200a4264187610/src/21_covariance_bnhls.jl#L1-L3">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HighFrequencyCovariance.parzen" href="#HighFrequencyCovariance.parzen"><code>HighFrequencyCovariance.parzen</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>A parzen kernel used in the bnhls covariance method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/HighFrequencyCovariance.jl/blob/4449051aff628d2a7e625bec54200a4264187610/src/21_covariance_bnhls.jl#L29-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HighFrequencyCovariance.quadratic_spectral" href="#HighFrequencyCovariance.quadratic_spectral"><code>HighFrequencyCovariance.quadratic_spectral</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>A quadratic_spectral kernel used in the bnhls covariance method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/HighFrequencyCovariance.jl/blob/4449051aff628d2a7e625bec54200a4264187610/src/21_covariance_bnhls.jl#L35-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HighFrequencyCovariance.fejer" href="#HighFrequencyCovariance.fejer"><code>HighFrequencyCovariance.fejer</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>A fejer kernel used in the bnhls covariance method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/HighFrequencyCovariance.jl/blob/4449051aff628d2a7e625bec54200a4264187610/src/21_covariance_bnhls.jl#L41-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HighFrequencyCovariance.tukey_hanning" href="#HighFrequencyCovariance.tukey_hanning"><code>HighFrequencyCovariance.tukey_hanning</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>A tukey_hanning kernel used in the bnhls covariance method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/HighFrequencyCovariance.jl/blob/4449051aff628d2a7e625bec54200a4264187610/src/21_covariance_bnhls.jl#L47-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HighFrequencyCovariance.bnhls_2008" href="#HighFrequencyCovariance.bnhls_2008"><code>HighFrequencyCovariance.bnhls_2008</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>A bnhls_2008 kernel used in the bnhls covariance method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/HighFrequencyCovariance.jl/blob/4449051aff628d2a7e625bec54200a4264187610/src/21_covariance_bnhls.jl#L53-L55">source</a></section></article><h3 id="Used-in-nearest-correlation-regularisation"><a class="docs-heading-anchor" href="#Used-in-nearest-correlation-regularisation">Used in nearest correlation regularisation</a><a id="Used-in-nearest-correlation-regularisation-1"></a><a class="docs-heading-anchor-permalink" href="#Used-in-nearest-correlation-regularisation" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="HighFrequencyCovariance.project_to_S" href="#HighFrequencyCovariance.project_to_S"><code>HighFrequencyCovariance.project_to_S</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">project_to_S(
    A::Hermitian,
    W_root::Union{Hermitian,Diagonal};
    W_inv_sqrt::Union{Hermitian,Diagonal} = sqrt_psd(inv(W_root^2)),
)

project_to_S(
    A::Diagonal,
    W_root::Union{Hermitian,Diagonal};
    W_inv_sqrt::Union{Hermitian,Diagonal,Missing} = missing,
)</code></pre><p>This maps a matrix to the nearest psd matrix. <code>W_root</code> should be the principal square root of a psd Hermitian weighting matrix, <code>W</code>. <code>W_inv_sqrt</code> should be the corresponding square root of the inverse of <code>W</code>. <code>nearest_psd_matrix</code> is a simpler interface for this function however it does not allow weighting matrices to be specified.</p><p><strong>Inputs</strong></p><ul><li><code>A</code> - The matrix you want to project to the S space. This can be a <code>Diagonal</code> or a <code>Hermitian</code>. Note that if you input a <code>Diagonal</code> matrix then it is already in the S space and so it will be returned without any calculation.</li><li><code>W_root</code> - The inverse weighting matrix.</li><li><code>W_inv_sqrt</code> - The root of <code>W_root</code>. This is calculated if you don&#39;t have it but it can save some calculation effort if you already have it.</li></ul><p><strong>Outputs</strong></p><ul><li>A <code>Hermitian</code>.</li></ul><p><strong>References</strong></p><p>Higham, N. J. 2001. Theorem 3.2</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/HighFrequencyCovariance.jl/blob/4449051aff628d2a7e625bec54200a4264187610/src/31_Regularisation_NearestCorrelationMatrix.jl#L60-L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HighFrequencyCovariance.project_to_U" href="#HighFrequencyCovariance.project_to_U"><code>HighFrequencyCovariance.project_to_U</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">project_to_U(A::Union{Diagonal,Hermitian}, invW::Hermitian)

project_to_U(A::Union{Diagonal,Hermitian}, invW::Diagonal)</code></pre><p>This maps the Hermitian/Hermitian matrix <code>A</code> to the nearest matrix in the U space (the space of all unit diagonal matrices as defined by Higham 2001). The inverse weight matrix <code>invW</code> determines how much to adjust each element to get it to be unit diagonal. In other words it is used to determine what is the nearest correlation matrix. The weight matrix must be Hermitian positive definite. We use the W-norm (as defined by Higham 2001).</p><p><strong>Inputs</strong></p><ul><li><code>A</code> - The matrix you want to project to the U space</li><li><code>invW</code> - The inverse weighting matrix.</li></ul><p><strong>Outputs</strong></p><ul><li>A <code>Diagonal</code> or a <code>Hermitian</code>.</li></ul><p><strong>References</strong></p><p>Higham, N. J. 2001. Bottom of page 335.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/HighFrequencyCovariance.jl/blob/4449051aff628d2a7e625bec54200a4264187610/src/31_Regularisation_NearestCorrelationMatrix.jl#L30-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HighFrequencyCovariance.iterate_higham" href="#HighFrequencyCovariance.iterate_higham"><code>HighFrequencyCovariance.iterate_higham</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">iterate_higham(
   Y::Union{Hermitian,Diagonal},
   Dykstra::Union{Hermitian,Diagonal},
   W_root::Union{Hermitian,Diagonal},
   W_inv::Union{Hermitian,Diagonal},
   W_inv_sqrt::Union{Hermitian,Diagonal},
)</code></pre><p>Do one iterate mapping the input matrix to the S space (of psd matrices) and then to the U space (unit diagonal and all other entries below 1 in absolute value). Returns the updated matrix and the next iterate&#39;s Dykstra correction.</p><p><strong>Inputs</strong></p><ul><li><code>Y</code> - The matrix you want to project to the iterate towards the space of valid correlation matrices.</li><li><code>Dykstra</code> - The Dykstra correction matrix.</li><li><code>W_root</code> - The root of <code>W</code>.</li><li><code>W_inv</code> - The inverse of <code>W</code>.</li><li><code>W_inv_sqrt</code> - The root of the inverse of <code>W</code>.</li></ul><p><strong>Outputs</strong></p><ul><li>A <code>Hermitian</code>.</li><li>An updated Dykstra correction matrix.</li></ul><p><strong>References</strong></p><p>Higham, N. J. 2001. Algorithm 3.3</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/HighFrequencyCovariance.jl/blob/4449051aff628d2a7e625bec54200a4264187610/src/31_Regularisation_NearestCorrelationMatrix.jl#L110-L133">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../helper_functions/">« Helper Functions</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Sunday 25 December 2022 04:38">Sunday 25 December 2022</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
